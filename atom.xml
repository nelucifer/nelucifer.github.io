<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coder立夏的笔记</title>
  <icon>https://www.gravatar.com/avatar/f0d08edbb92c84449cb9aa170181da16</icon>
  <subtitle>JavaWeb开发|热爱分享|开发学习笔记|码梦者学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wanglixia.top/"/>
  <updated>2019-02-19T15:46:06.203Z</updated>
  <id>https://www.wanglixia.top/</id>
  
  <author>
    <name>coder立夏</name>
    <email>ne_lucifer@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring系列学习之IoC与AOP</title>
    <link href="https://www.wanglixia.top/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1.html"/>
    <id>https://www.wanglixia.top/spring学习笔记-1.html</id>
    <published>2019-02-16T08:47:04.000Z</published>
    <updated>2019-02-19T15:46:06.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spirng中的两个核心概念：依赖注入DI（dependency injection）和面向切面编程AOP（aspect-oriented programming）。 </p><blockquote><p>为了降低Java开发的复杂性，Spring采取了以下四种关键策略：</p><ul><li>基于POJO（Plain Old Java Object）的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和管理进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul></blockquote><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>传统的做法，每个对象负责管理它所依赖的对象的引用，这将会导致高度耦合和难以测试的代码。比如说，对象A要使用对象B，则在对象A中来控制对象B，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.sayHello(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span>+ userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>耦合具有两面性，一方面，紧密耦合的代码难以测试、难以复用、难以理解；另一方面，一定程度的耦合又是必须的——完全没有耦合的代码什么也做不了。总之，耦合是必须的，但是应当被合理地管理。</p><p>创建应用组件之间协作的行为通常称为装配。Spring有多种装配bean的方式，采用XMl、使用Java进行配置。</p><p>通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定。<br>依赖注入的方式：</p><ol><li>构造器注入；</li><li>setter注入；</li><li>基于注解注入；</li></ol><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.sayHello(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>xml方式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"com.lucifer.spring.di.A"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 注册B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">class</span>=<span class="string">"com.lucifer.spring.di.B"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"com.lucifer.spring.di.A"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意：这两种写法都可以，Spring将name值得每个单词的首字母转换为大写，再在前面拼上set构成set方法名，然后去对应的类中查找这个方法，通过反射调用实现注入，仅按照此种规则匹配，即对应的成员变量命名不做约束。也就是说 UserName 和 userName 都能匹配上 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 写法一 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name="UserName" ref="b"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 写法二 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">ref</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 注册B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">class</span>=<span class="string">"com.lucifer.spring.di.B"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String userName123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span>+ userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName123 = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于注解的注入"><a href="#基于注解的注入" class="headerlink" title="基于注解的注入"></a>基于注解的注入</h3><p>bean的属性autowire，autowire主要有三个属性值：constructor，byName，byType。</p><ul><li>constructor：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。</li><li>byName：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词的首字母必须小写，这个和手动set注入有点不同。</li><li>byType：查找所有的set方法，将符合参数类型的bean注入。</li></ul><p>注册bean的注解有以下几种：</p><ol><li>@Component：用于注册所有的bean；</li><li>@Repository：用于注册dao层的bean；</li><li>@Controller：用于注册控制层的bean；</li><li>@Service：用于注册服务层的bean；</li></ol><p>常见的问题，@Resource和@Autowired之间的区别是什么？<br>描述依赖关系的主要有两种：</p><ul><li>@Resource：java的注解，默认以byName的方式去匹配与属性名相同的bean的id，如果没有再以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（Spring注解）指定某个具体名称的bean；</li><li>@Autowired：spring注解，默认是以byType的方式去匹配类型相同的bean，如果匹配到一个，那么就直接注入该bean，无论要注入的bean的那么是什么；如果匹配到多个，就会调用DefaultListableBeanFactory的determineAutowireCandidate方法来决定具体注入哪个bean。</li></ul><p>determineAutowireCandidate方法的逻辑是：</p><ol><li>先找Bean上有@Primary注解的，有则直接返回bean的name；</li><li>再找Bean上有@Order，@PriorityOrder注解的，有则返回bean的name；</li><li>最后再以名称匹配（ByName）的方式去查找相匹配的bean。</li><li>没有找到的话就抛出异常。</li></ol><p>还有一点要注意：如果使用了 @Qualifier 注解，那么当自动装配匹配到多个 bean 的时候就不会进入 determineAutowireCandidate 方法，而是直接查找与 @Qualifer 指定的 bean name 相同的 bean 去注入，找到了就直接注入，没有找到则抛出异常。</p><p><strong>注意</strong><br>如果通过set方法注入属性，那么Spring会通过默认的无参构造方法来实例化对象，所以如果在类中重写带有参数的构造方法，一定要把无参构造方法也写上，否则spring没有办法实例化对象，导致报错。</p><h3 id="问题一：依赖注入（DI）和控制反转（IoC）有什么关系？"><a href="#问题一：依赖注入（DI）和控制反转（IoC）有什么关系？" class="headerlink" title="问题一：依赖注入（DI）和控制反转（IoC）有什么关系？"></a>问题一：依赖注入（DI）和控制反转（IoC）有什么关系？</h3><ul><li><p><strong>谁控制谁，控制什么：</strong> 传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p></li><li><p><strong>为何是反转，哪些方面反转了：</strong> IoC：Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想，传统应用程序是由我们自己在对象中主动去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象，为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p></li></ul><p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”</p><ul><li><strong>谁依赖谁：</strong> 应用程序依赖于IoC容器；</li><li><strong>为什么需要依赖：</strong> 应用程序需要IoC容器来提供对象需要的外部资源；</li><li><strong>谁注入谁：</strong> 很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</li><li><strong>注入了什么：</strong> 就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</li></ul><p>其实IoC和DI是同一个概念的不同角度描述，由于控制反转概念比较模糊（可能只是理解为容易控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。<br>我认为可以这么理解：使用依赖注入来实现了控制反转。</p><h2 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h2><p>DI能够让相互协作的软件组件保持松散耦合，而面向切面编程（aspect-oriented programming）允许把遍布在应用各处的功能分离出来形成可重用的组件。定义切点的表达式的语法采用的是AspectJ的切点表达式语言。</p><h3 id="AOP的八个概念"><a href="#AOP的八个概念" class="headerlink" title="AOP的八个概念"></a>AOP的八个概念</h3><ol><li>Aspect（切面）：通知和切点共同定义了切面的全部内容；</li><li>Joint Point（连接点）：程序执行过程中明确的点，是在应用执行过程中能够插入切面的一个点，切面代码利用这些点插入到应用的正常流程之中并添加新的行为；</li><li>Advice（通知）：AOP在特定的切入点上执行的增强处理，五个通知类型：<ol><li>前置通知（Before）：在目标方法被调用之前调用通知功能，@Before只需要指定切入点表达式即可；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不关心方法的输出是什么。不论拦截的方法是否有异常。在目标方法完成之后做增强，无论目标方法什么时候成功完成。@After可以指定一个切入点表达式；</li><li>环绕通知（Around）：需要放行操作。通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。环绕通知是最重要的通知类型，像事务、日志等都是环绕通知；</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知，@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning，代表目标方法的返回值；</li><li>异常通知（After-throwing）：主要用来处理程序中未处理的异常，在目标抛出异常后调用通知，@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名，可以通过该形参名来访问目标方法中所抛出的异常对象；</li></ol></li><li>Pointcut（切入点）：带有通知的连接点，在程序中主要体现为书写切入点表达式。如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”；</li><li>AOP代理：AOP框架创建的对象，代理就是目标对象的增强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类；</li><li>织入（Weaving）：实现AOP代理所声明的功能，即把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期中，可以在编译期、类加载期、运行期进行织入；</li><li>关注点：切面的具体功能方法被称为关注点。</li></ol><table><thead><tr><th style="text-align:left">注解</th><th style="text-align:left">通知</th></tr></thead><tbody><tr><td style="text-align:left">@After</td><td style="text-align:left">通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td style="text-align:left">@AfterReturning</td><td style="text-align:left">通知方法会在目标方法返回后调用</td></tr><tr><td style="text-align:left">@AfterThrowing</td><td style="text-align:left">通知方法会在目标方法抛出异常后调用</td></tr><tr><td style="text-align:left">@Around</td><td style="text-align:left">通知方法会将目标方法封装起来</td></tr><tr><td style="text-align:left">@Before</td><td style="text-align:left">通知方法会在目标方法调用之前执行</td></tr></tbody></table><p>Spring提供了4种类型的AOP支持：</p><ul><li>基于代理的经典Spring AOP；</li><li>纯POJO切面；</li><li>@AspectJ注解驱动的切面；</li><li>注入式AspectJ切面（适用于Spring各版本）；</li></ul><p>前面三种都是Spring AOP实现的变体，Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截；也正是因为Spring基于动态代理，所以Spring只支持方法连接点。</p><p>AOP主要的作用是：日志记录，性能统计，安全控制，事务处理，异常处理，权限登录等等。AOP代理由Spring的IoC容器负责生成、管理，其依赖关系也由IoC容器负责管理。</p><h3 id="Spring借助AspectJ的切点表达式语言来定义Spring切面"><a href="#Spring借助AspectJ的切点表达式语言来定义Spring切面" class="headerlink" title="Spring借助AspectJ的切点表达式语言来定义Spring切面"></a>Spring借助AspectJ的切点表达式语言来定义Spring切面</h3><p>Spring AOP所支持的AspectJ切点指示器<br>|AspectJ指示器|描述|<br>|:–|:–|<br>|arg()|限制连接点匹配参数为指定类型的执行方法|<br>|@args()|限制连接点匹配参数由指定注解标注的执行方法|<br>|execution()|用于匹配是连接点的执行方法|<br>|this()|限制连接点匹配AOP代理的bean引用为指定类型的类|<br>|target|限制连接点匹配目标对象为指定类型的类|<br>|@target()|限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解|<br>|within()|限制连接点匹配指定的类型|<br>|@within()|限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里）|<br>|@annotation|限定匹配带有指定注解的连接点|</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">execution(* concert.Performance.perform(..))</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*：返回任意类型；</span></span><br><span class="line"><span class="comment">concert.Performance：方法所属的类；</span></span><br><span class="line"><span class="comment">perform：方法；</span></span><br><span class="line"><span class="comment">..：使用任意参数；</span></span><br><span class="line"><span class="comment">execution：在方法执行时触发；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>Spring常用的三种注入方式:<a href="https://blog.csdn.net/a909301740/article/details/78379720" target="_blank" rel="noopener">https://blog.csdn.net/a909301740/article/details/78379720</a></p><p>IoC基础——跟我学Spring3<a href="https://jinnianshilongnian.iteye.com/blog/1413846" target="_blank" rel="noopener">https://jinnianshilongnian.iteye.com/blog/1413846</a></p><p>Spring 实战（第四版） [美]Craig Walls 著 张卫滨 译</p><hr><p>欢迎扫描下方二维码，关注weyoung公众号，一起交流学习~~</p><p><img src="https://img-blog.csdnimg.cn/20190110204409607.jpg" alt="个人微信公众号：记录一些学习过程中遇到的坑，欢迎关注交流"></p><p><strong>更多联系方式</strong></p><table><thead><tr><th style="text-align:left">平台</th><th style="text-align:left">链接</th></tr></thead><tbody><tr><td style="text-align:left">预览项目：</td><td style="text-align:left"><a href="https://nelucifer.gitee.io/" target="_blank" rel="noopener">https://nelucifer.gitee.io/</a></td></tr><tr><td style="text-align:left">个人微信公众号：</td><td style="text-align:left">weyoung</td></tr><tr><td style="text-align:left">segmentfault:</td><td style="text-align:left"><a href="https://segmentfault.com/u/nelucifer" target="_blank" rel="noopener">https://segmentfault.com/u/nelucifer</a></td></tr><tr><td style="text-align:left">CSDN:</td><td style="text-align:left"><a href="https://me.csdn.net/wlx001" target="_blank" rel="noopener">https://me.csdn.net/wlx001</a></td></tr><tr><td style="text-align:left">简书：</td><td style="text-align:left"><a href="https://www.jianshu.com/u/99211cc23788" target="_blank" rel="noopener">https://www.jianshu.com/u/99211cc23788</a></td></tr><tr><td style="text-align:left">掘金：</td><td style="text-align:left"><a href="https://juejin.im/user/59b08c575188250f4850e80e" target="_blank" rel="noopener">https://juejin.im/user/59b08c575188250f4850e80e</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Spirng中的两个核心概念：依赖注入DI（dependency injection）和面向切面编程AOP（aspect-oriented 
      
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="框架" scheme="https://www.wanglixia.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://www.wanglixia.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架整合笔记</title>
    <link href="https://www.wanglixia.top/ssm%E6%A1%86%E6%9E%B6-%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0.html"/>
    <id>https://www.wanglixia.top/ssm框架-整合笔记.html</id>
    <published>2019-02-16T06:52:50.000Z</published>
    <updated>2019-02-18T12:00:39.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;接触SSM框架到现在也有很长时间了，之前也搭建过几个简单的项目，但是没有进行过记录学习和搭建的过程。网上关于ssm框架整合的资料也不少，不过说句实话，单看某一篇文章能够不踩坑的配置并跑起来的也不太多，在学习过程中筛选甄别这些就浪费了相当一部分时间。</p><h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><p>&emsp;&emsp;本文先理论，再实践，后思想的方式，分享ssm的相关概念以及采用实践操作的方式搭建整套系统。把之前踩过的坑、笔记记录整理一下，用以和感兴趣的朋友分享下。</p><h2 id="概念整理"><a href="#概念整理" class="headerlink" title="概念整理"></a>概念整理</h2><p>这块对于相关的概念进行整理，如果只是想知道框架怎么整合和搭建而并不想知道为什么的话，可以直接去看下文中的实践步骤了。</p><ol><li>Spring</li></ol><p>&emsp;&emsp;我们看一下百度百科对于spring框架的释义：</p><blockquote><p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p></blockquote><p>为什么Spring用来完成EJB完成的事情，那么这个EJB是什么玩意？概念：</p><blockquote><p>EJB：Enterprise JavaBean，对于商务软件来说，其核心部分就是她的业务逻辑，业务逻辑抽象了整个商务过程的流程，并使用计算机语言将他们实现。<br>……<br>J2EE对于这个问题的处理方法是将业务逻辑从客户端软件中抽取出来，封装在一个组件中。这个组件运行在一个独立的服务器上，客户端软件通过网络调用组件提供的服务来实现业务逻辑，而客户端软件的仅仅负责发送调用请求和显示处理结果。在J2EE中，这个运行在一个独立的服务器上，并封装了业务逻辑的组件就是EJB组件。</p></blockquote><p>从上面的概念中，可以理解为EJB概念说的就是C/S软件，简单来说EJB 就是将那些”类”放到一个服务器上，用C/S 形式的软件客户端对服务器上的”类”进行调用。<br>感兴趣的可以看下这篇文章<a href="https://blog.csdn.net/jojo52013145/article/details/5783677" target="_blank" rel="noopener">https://blog.csdn.net/jojo52013145/article/details/5783677</a></p><p>为了降低Java开发的复杂性，Spring采取了以下四种关键策略：</p><ul><li>基于POJO（Plain Old Java Object）的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和管理进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><ul><li>Maven</li><li>IDEA</li><li>Tomcat</li></ul><h2 id="实践步骤"><a href="#实践步骤" class="headerlink" title="实践步骤"></a>实践步骤</h2><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;接触SSM框架到现在也有很长时间了，之前也搭建过几个简单的项目，但是没有进行过记录学习和搭建的过程。网上关于ssm框
      
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="框架" scheme="https://www.wanglixia.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://www.wanglixia.top/tags/spring/"/>
    
      <category term="springmvc" scheme="https://www.wanglixia.top/tags/springmvc/"/>
    
      <category term="mybatis" scheme="https://www.wanglixia.top/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>jQuery学习笔记（四）DOM篇</title>
    <link href="https://www.wanglixia.top/jQuery-usage-4.html"/>
    <id>https://www.wanglixia.top/jQuery-usage-4.html</id>
    <published>2019-01-31T08:58:36.000Z</published>
    <updated>2019-02-03T06:41:07.723Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.wanglixia.top/logo-jquery-20191111489.jpg" alt="logo-jquery-20191111489"></p><a id="more"></a><h3 id="DOM包裹wrap-方法"><a href="#DOM包裹wrap-方法" class="headerlink" title="DOM包裹wrap()方法"></a>DOM包裹wrap()方法</h3><p>如果要将元素用其他元素包裹起来，也就是给它增加一个父元素，JQuery提供了一个wrap方法</p><ul><li><code>.wrap(wrappingElement)</code>：在集合中匹配的每个元素周围包裹一个HTML结构</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>给p元素增加一个div包裹</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).wrap(<span class="string">'&lt;div&gt;&lt;/div&gt;'</span>)</span><br></pre></td></tr></table></figure><p>最后的结构，p元素增加了一个父div的结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>.wrap(function)</code> ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象<br>使用后的效果与直接传递参数是一样，只不过可以把代码写在函数体内部，写法不同而已<br>以第一个案例为例：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).wrap(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;div&gt;&lt;/div&gt;'</span>;   <span class="comment">//与第一种类似，只是写法不一样</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>.wrap()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套好几层深，但应该只包含一个核心的元素。每个匹配的元素都会被这种结构包裹。该方法返回原始的元素集，以便之后使用链式方法。</p><h3 id="DOM包裹unwrap-方法"><a href="#DOM包裹unwrap-方法" class="headerlink" title="DOM包裹unwrap()方法"></a>DOM包裹unwrap()方法</h3><p>unwarp()方法 ，作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要删除这段代码中的div，一般常规的方法会直接通过remove或者empty方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).remove();</span><br></pre></td></tr></table></figure><p>但是如果还要保留内部元素p</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).unwarp();</span><br></pre></td></tr></table></figure><p>找到p元素，然后调用unwarp方法，这样只会删除父辈div元素了<br>结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个方法不接受任何参数。</p><h3 id="DOM包裹wrapAll-方法"><a href="#DOM包裹wrapAll-方法" class="headerlink" title="DOM包裹wrapAll()方法"></a>DOM包裹wrapAll()方法</h3><p>wrap是针对单个dom元素处理，如果要将集合中的元素用其他元素包裹起来，也就是给他们增加一个父元素，针对这样的处理，JQuery提供了一个wrapAll方法<br><code>.wrapAll(wrappingElement)</code>：给集合中匹配的元素增加一个外面包裹HTML结构<br>简单的看一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>给所有p元素增加一个div包裹</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).wrapAll(<span class="string">'&lt;div&gt;&lt;/div&gt;'</span>)</span><br></pre></td></tr></table></figure><p>最后的结构，2个P元素都增加了一个父div的结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>.wrapAll(function)</code> ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象<br>通过回调的方式可以单独处理每一个元素<br>以上面案例为例，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).wrapAll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;div&gt;&lt;div/&gt;'</span>; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上的写法的结果如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br><code>.wrapAll()</code>函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套多层，但是最内层只能有一个元素。所有匹配元素将会被当作是一个整体，在这个整体的外部用指定的 HTML 结构进行包裹。</p><h3 id="DOM包裹wrapInner-方法"><a href="#DOM包裹wrapInner-方法" class="headerlink" title="DOM包裹wrapInner()方法"></a>DOM包裹wrapInner()方法</h3><p>将合集中的元素内部所有的子元素用其他元素包裹起来，并当作指定元素的子元素<br><code>.wrapInner( wrappingElement )</code>：给集合中匹配的元素的内部，增加包裹的HTML结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>给所有元素增加一个p包裹</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).wrapInner(<span class="string">'&lt;p&gt;&lt;/p&gt;'</span>)</span><br></pre></td></tr></table></figure><p>最后的结构，匹配的di元素的内部元素被p给包裹了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>.wrapInner(function)</code> ：允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行，返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容。<br>以上面案例为例，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).wrapInner(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;p&gt;&lt;/p&gt;'</span>; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>当通过一个选择器字符串传递给<code>.wrapInner()</code> 函数，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。</p><h3 id="jQuery遍历之children-方法"><a href="#jQuery遍历之children-方法" class="headerlink" title="jQuery遍历之children()方法"></a>jQuery遍历之children()方法</h3><p><code>.children(selector)</code> 方法是返回匹配元素集合中每个元素的所有子元素（仅儿子辈，这里可以理解为就是父亲-儿子的关系）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"grandson"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码如果是<code>$(“div”).children()</code>，那么意味着只能找到ul，因为div与ul是父子关系，li与div是祖辈关系，因此无法找到。</p><ul><li><p>children()无参数<br>允许我们通过在DOM树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的jQuery对象<br>注意：jQuery是一个合集对象，所以通过children是匹配合集中每一给元素的第一级子元素</p></li><li><p>.children()方法选择性地接受同一类型选择器表达式</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).children(<span class="string">".selected"</span>)</span><br><span class="line"></span><br><span class="line">$(<span class="string">'.div'</span>).children().css(<span class="string">'border'</span>, <span class="string">'3px solid red'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到所有class=div的元素</span></span><br><span class="line"><span class="comment">//找到其对应的子元素ul，然后筛选出最后一个，给边宽加上颜色</span></span><br><span class="line">$(<span class="string">'.div'</span>).children(<span class="string">':last'</span>).css(<span class="string">'border'</span>, <span class="string">'3px solid blue'</span>)</span><br></pre></td></tr></table></figure><h3 id="jQuery遍历之find-方法"><a href="#jQuery遍历之find-方法" class="headerlink" title="jQuery遍历之find()方法"></a>jQuery遍历之find()方法</h3><p>jQuery是一个合集对象，快速查找DOM树中的这些元素的后代元素可以用find()方法，这也是开发使用频率很高的方法。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"grandson"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>$(“div”).find(“li”)</code>，li与div是祖辈关系，通过find方法就可以快速的查找到了。</p><p><code>.find()</code>方法要注意的知识点：</p><ul><li>find是遍历当前元素集合中每个元素的后代。只要符合，不管是儿子辈，孙子辈都可以。</li><li>与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 ‘*’。</li><li>find只在后代中遍历，不包括自己。</li><li>选择器 context 是由 .find() 方法实现的；因此，$(‘.item-ii’).find(‘li’) 等价于 $(‘li’, ‘.item-ii’)(找到类名为item-ii的标签下的li标签)。</li></ul><p><strong>注意：</strong><br><code>.find()</code>和<code>.children()</code>方法是相似的</p><ol><li>children只查找第一级的子节点，是父子关系查找</li><li>find查找范围包括子节点的所有后代节点，（包含父子关系）</li></ol><h3 id="jQuery遍历之parent-方法"><a href="#jQuery遍历之parent-方法" class="headerlink" title="jQuery遍历之parent()方法"></a>jQuery遍历之parent()方法</h3><p>快速查找合集里面的每一个元素的父元素（父亲-儿子的关系），此时可以用parent()方法，这个方法只会向上查找一级<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"grandson"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找ul的父元素div</span></span><br><span class="line">$(ul).parent()</span><br></pre></td></tr></table></figure><p>parent()无参数<br>parent()方法允许在DOM树中搜索到这些元素的父级元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象</p><p>注意：jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素<br>parent()方法选择性地接受同一型选择器表达式,同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p><h3 id="jQuery遍历之parents-方法"><a href="#jQuery遍历之parents-方法" class="headerlink" title="jQuery遍历之parents()方法"></a>jQuery遍历之parents()方法</h3><p>快速查找合集里面的每一个元素的所有祖辈元素，此时可以用parents()方法<br>其实也类似find与children的区别，parent只会查找一级，parents则会往上一直查到查找到祖先节点<br>理解节点查找关系：</p><p><div class="div"><br>    <ul class="son"><br>        <li class="grandson">1</li><br>    </ul><br></div><br>在li节点上找到祖 辈元素div， 这里可以用$(“li”).parents()方法</p><ul><li><p>parents()无参数<br>parents()方法允许在DOM树中搜索到这些元素的祖先元素，有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象;<br>返回的元素秩序是从离他们最近的父级元素开始的<br>注意：jQuery是一个合集对象，所以通过parent是匹配合集中所有元素的祖辈元素</p></li><li><p>parents()方法选择性地接受同一型选择器表达式<br>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式<br>注意事项：</p></li></ul><ol><li>.parents()和.parent()方法是相似的，但后者只是进行了一个单级的DOM树查找</li><li>$( “html” ).parent()方法返回一个包含document的集合，而$( “html” ).parents()返回一个空集合。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到当前元素的所有祖辈元素,筛选出class="first-div"的元素</span></span><br><span class="line"><span class="comment">//并且附上一个边</span></span><br><span class="line">$(<span class="string">'.item-b'</span>).parents(<span class="string">'.first-div'</span>).css(<span class="string">'border'</span>, <span class="string">'2px solid blue'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.wanglixia.top/logo-jquery-20191111489.jpg&quot; alt=&quot;logo-jquery-20191111489&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="前端" scheme="https://www.wanglixia.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="jQuery" scheme="https://www.wanglixia.top/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>人人都可快速上手的GitBook使用笔记（持续更新中）</title>
    <link href="https://www.wanglixia.top/gitbook-usage.html"/>
    <id>https://www.wanglixia.top/gitbook-usage.html</id>
    <published>2019-01-13T11:57:18.000Z</published>
    <updated>2019-01-15T12:41:51.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>GitBook是Markdown与HTML完美的结合。</p><blockquote><p>百科介绍：GitBook是一个基于Node.js的命令行工具，可通过Markdown来制作电子书、在线文档等。<br>GitBook支持输出多种格式：</p><ol><li>PDF： 需要安装gitbook-pdf依赖；</li><li>eBook： 需要安装ebook-convert；</li><li>单HTML网页： 支持将内容输出为单页的HTML。</li></ol></blockquote><a id="more"></a><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ul><li>需要安装Node.js；</li><li>安装GitBook命令行工具；</li><li>MarkDown常用语法；</li></ul><h2 id="本文介绍环境配置"><a href="#本文介绍环境配置" class="headerlink" title="本文介绍环境配置"></a>本文介绍环境配置</h2><ul><li>NPM版本： 5.6.0</li><li>OS版本：Windows10</li><li>CLI version: 2.3.2</li><li>GitBook version: 3.2.3</li></ul><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li>Gitbook好用的插件：<a href="https://plugins.gitbook.com/" target="_blank" rel="noopener">https://plugins.gitbook.com/</a></li><li>Gitbook使用文档：<a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="noopener">https://github.com/GitbookIO/gitbook</a></li></ul><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>GitBook的初始化，编译和预览等均需要在命令行进行，就像hexo编写个人博客一样。</p><h3 id="安装GitBook工具"><a href="#安装GitBook工具" class="headerlink" title="安装GitBook工具"></a>安装GitBook工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-cli -g</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>新建一个目录，命令行打开该目录，然后以下输入命令，就可以初始化书籍，生成两个文件（没有生成其他教程说的book.json）：</p><ul><li><code>README.md</code>：书籍介绍</li><li><code>SUMMARY.md</code>：书籍目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></figure><h3 id="编译成html"><a href="#编译成html" class="headerlink" title="编译成html"></a>编译成html</h3><p>生成的文件在上述目录下的_book文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook build</span><br></pre></td></tr></table></figure><h3 id="本地进行预览"><a href="#本地进行预览" class="headerlink" title="本地进行预览"></a>本地进行预览</h3><p>浏览器中打开<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>进行预览。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></figure><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook update <span class="comment"># 更新gitbook</span></span><br></pre></td></tr></table></figure><h3 id="手动给GitBook添加book-json"><a href="#手动给GitBook添加book-json" class="headerlink" title="手动给GitBook添加book.json"></a>手动给GitBook添加book.json</h3><p>因为使用<code>gitbook init</code>生成的目录默认是没有book.json的，那么要引入其他的插件的话就需要自己<strong>手动</strong>在<strong>根目录</strong>创建一个<code>book.json</code>，<br>配置之后需要使用<code>gitbook install</code>安装<code>book.json</code>中配置的插件。<br>基本格式如下：</p><pre><code class="json">{  <span class="attr">"gitbook"</span>: <span class="string">"3.2.3"</span>,  <span class="attr">"title"</span>: <span class="string">"标题"</span>,  <span class="attr">"description"</span>: <span class="string">"文档描述"</span>,  <span class="attr">"author"</span>: <span class="string">"作者"</span>,  <span class="attr">"language"</span>: <span class="string">"zh-hans"</span>,  <span class="attr">"links"</span>: {    <span class="attr">"gitbook"</span>: <span class="literal">true</span>,    <span class="attr">"sharing"</span>: {      <span class="attr">"google"</span>: <span class="literal">false</span>,      <span class="attr">"facebook"</span>: <span class="literal">false</span>,      <span class="attr">"twitter"</span>: <span class="literal">false</span>,      <span class="attr">"all"</span>: <span class="literal">false</span>    }  },//分享按钮是否展示  "plugins": [    "github",    "donate",    "splitter",    "anchor-navigation-ex",    "-sharing",    "sharing-plus",    "-highlight",    "prism",    "disqus",    "editlink",    "baidu",    "sitemap",    "tbfed-pagefooter",    "fontsettings",    "simple-page-toc",    <span class="string">"links"</span>  ],  "pluginsConfig": {    "tbfed-pagefooter": {      "copyright": "",      "modify_label": "文件修改时间：",      "modify_format": "YYYY-MM-DD HH:mm:ss"    },// 文件的修改时间，以及版权声明等    "simple-page-toc": {      "maxDepth": 3,      "skipFirstH1": true    },    "sharing": {      "douban": false,      "facebook": false,      "google": false,      "hatenaBookmark": false,      "instapaper": false,      "line": false,      "linkedin": false,      "messenger": false,      "pocket": false,      "qq": false,      "qzone": false,      "stumbleupon": false,      "twitter": false,      "viber": false,      "vk": false,      "weibo": false,      "whatsapp": false,      "all": [        "weibo",        "qq",        "qzone",        "google",        <span class="string">"douban"</span>      ]    },    "github": {      "url": "https://github.com/nelucifer"    },    "donate": {      "wechat": "",      "title": "",      "button": "赏",      "wechatText": "微信打赏"    },    "anchor-navigation-ex": {      "associatedWithSummary": false,      "showLevel": true,      "multipleH1": true,      "mode": "float",      "pageTop": {        "showLevelIcon": false,        "level1Icon": "fa fa-hand-o-right",        "level2Icon": "fa fa-hand-o-right",        "level3Icon": "fa fa-hand-o-right"      }    },    "theme-default": {      "showLevel": true    },    "fontsettings": {      "theme": "white",      "family": "serif",      "size": 2    },// 显示样式以及文字大小的主题    "sidebar": {    },    "disqus": {      "shortName": "webpack-handbook" //生成评论    },    "github": {      "url": "https://github.com/nelucifer/front-template"    },    "editlink": {      "base": "https://github.com/nelucifer/",      "label": "编辑本页面" //内容顶部显示 编辑本页 链接，点击跳转到配置的源码存放位置    },    "baidu": {      "token": "" //百度站长工具统计    },    "sitemap": {      "hostname": "http://baidu.com/"//站点地图    },    "prism": {      "css": [        <span class="string">"prismjs/themes/prism-tomorrow.css"</span>      ]    }  }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;GitBook是Markdown与HTML完美的结合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;百科介绍：GitBook是一个基于Node.js的命令行工具，可通过Markdown来制作电子书、在线文档等。&lt;br&gt;GitBook支持输出多种格式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PDF： 需要安装gitbook-pdf依赖；&lt;/li&gt;
&lt;li&gt;eBook： 需要安装ebook-convert；&lt;/li&gt;
&lt;li&gt;单HTML网页： 支持将内容输出为单页的HTML。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="GitBook" scheme="https://www.wanglixia.top/tags/GitBook/"/>
    
  </entry>
  
  <entry>
    <title>redis系列——windows下redis设置及安装windows服务</title>
    <link href="https://www.wanglixia.top/redis-windows-install.html"/>
    <id>https://www.wanglixia.top/redis-windows-install.html</id>
    <published>2019-01-06T04:44:00.000Z</published>
    <updated>2019-01-15T11:49:49.265Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.wanglixia.top/redis-logo-2019115132039.jpg" alt="redis-logo-2019115132039"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis是一个开源（BSD许可），内存数据结构存储，用作数据库，缓存和消息代理。 它支持数据结构，如字符串，散列，列表，集合，带有范围查询的排序集，位图，超级日志，带有半径查询和流的地理空间索引。 Redis具有内置复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用性并使用Redis Cluster自动分区。本文简单记录一下windows下redis设置及安装成windows服务。<br><a id="more"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p></li><li><p>百度百科：Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。<br>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p></li><li>官网介绍: Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.<br>Google 翻译：Redis是一个开源（BSD许可），内存数据结构存储，用作数据库，缓存和消息代理。 它支持数据结构，如字符串，散列，列表，集合，带有范围查询的排序集，位图，超级日志，带有半径查询和流的地理空间索引。 Redis具有内置复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用性并使用Redis Cluster自动分区。</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="下载windows版的redis（解压版），下载地址：https-github-com-ServiceStack-redis-windows-tree-master-downloads"><a href="#下载windows版的redis（解压版），下载地址：https-github-com-ServiceStack-redis-windows-tree-master-downloads" class="headerlink" title="下载windows版的redis（解压版），下载地址：https://github.com/ServiceStack/redis-windows/tree/master/downloads"></a>下载windows版的redis（解压版），下载地址：<a href="https://github.com/ServiceStack/redis-windows/tree/master/downloads" target="_blank" rel="noopener">https://github.com/ServiceStack/redis-windows/tree/master/downloads</a></h3><h3 id="下载Redis可视化工具-Redis-Desktop-Manager，"><a href="#下载Redis可视化工具-Redis-Desktop-Manager，" class="headerlink" title="下载Redis可视化工具 Redis Desktop Manager，"></a>下载Redis可视化工具 Redis Desktop Manager，</h3><h4 id="下载地址：https-redisdesktop-com-download"><a href="#下载地址：https-redisdesktop-com-download" class="headerlink" title="下载地址：https://redisdesktop.com/download"></a>下载地址：<a href="https://redisdesktop.com/download" target="_blank" rel="noopener">https://redisdesktop.com/download</a></h4><h4 id="百度网盘：链接：https-pan-baidu-com-s-1vcRywB4JTA2xPCUvh0n1DA-提取码：y1vv"><a href="#百度网盘：链接：https-pan-baidu-com-s-1vcRywB4JTA2xPCUvh0n1DA-提取码：y1vv" class="headerlink" title="百度网盘：链接：https://pan.baidu.com/s/1vcRywB4JTA2xPCUvh0n1DA 提取码：y1vv"></a>百度网盘：链接：<a href="https://pan.baidu.com/s/1vcRywB4JTA2xPCUvh0n1DA" target="_blank" rel="noopener">https://pan.baidu.com/s/1vcRywB4JTA2xPCUvh0n1DA</a> 提取码：y1vv</h4><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="解压redis-64-3-0-503-zip；cmd命令进入该目录"><a href="#解压redis-64-3-0-503-zip；cmd命令进入该目录" class="headerlink" title="解压redis-64.3.0.503.zip；cmd命令进入该目录"></a>解压<strong>redis-64.3.0.503.zip</strong>；cmd命令进入该目录</h3><table><thead><tr><th style="text-align:center">文件</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">redis-server</td><td style="text-align:center">启动redis</td></tr><tr><td style="text-align:center">redis-cli</td><td style="text-align:center">redis命令行工具</td></tr><tr><td style="text-align:center">redis-benchmark</td><td style="text-align:center">基准测试工具</td></tr><tr><td style="text-align:center">redis-check-aof</td><td style="text-align:center">AOF持久化文件检测工具和修复工具</td></tr><tr><td style="text-align:center">redis-check-dump</td><td style="text-align:center">RDB持久化文件检测工具和修复工具</td></tr><tr><td style="text-align:center">redis-sentinel</td><td style="text-align:center">启动redis-sentinel</td></tr></tbody></table><p>在解压后的文件夹里面，按住<code>shift</code>，然后鼠标右键点击空白区域，选择【在此处打开命令窗口】，快捷打开cmd窗口和当前目录。</p><h3 id="启动："><a href="#启动：" class="headerlink" title="启动："></a>启动：</h3><h4 id="带配置文件启动redis"><a href="#带配置文件启动redis" class="headerlink" title="带配置文件启动redis:"></a>带配置文件启动redis:</h4><p><code>redis.windows.conf</code> 这个文件是redis的配置文件，使用以下命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis-windows.conf</span><br></pre></td></tr></table></figure><h4 id="不带配置文件启动："><a href="#不带配置文件启动：" class="headerlink" title="不带配置文件启动："></a>不带配置文件启动：</h4><p>双击<code>redis-server.exe</code>；或者使用以下命令启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe</span><br></pre></td></tr></table></figure></p><h3 id="出现如下图时，启动成功。"><a href="#出现如下图时，启动成功。" class="headerlink" title="出现如下图时，启动成功。"></a>出现如下图时，启动成功。</h3><p><img src="http://img.wanglixia.top/redis-windows-install-1-2019110133458.png" alt="redis-windows-install-1-2019110133458"></p><h3 id="登录redis"><a href="#登录redis" class="headerlink" title="登录redis"></a>登录redis</h3><p>启动redis服务后，需要登录redis来进行操作，这个时候需要按照上面步骤重新打开一个命令窗口，使用<code>redis-cli</code>命令进行登录，命令如下</p><ul><li>-h 服务器/主机地址，本地就是<code>127.0.0.1</code></li><li>-p 端口号，默认应该是6379</li><li>-a 密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -a lucifer</span><br></pre></td></tr></table></figure><p>登录成功后，如下图示：<br><img src="http://img.wanglixia.top/redis-windows-install-登录成功-2-2019110163813.png" alt="redis-windows-install-登录成功-2-2019110163813"></p><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><p>打开redis.conf配置文件，我下载的版本配置文件名是<code>redis-windows.conf</code>，找到# requirepass foobared，去掉注释，井号代表注释，然后修改如下即可:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass 你的密码 <span class="comment">#我设置的是lucifer</span></span><br></pre></td></tr></table></figure></p><h2 id="安装成windows服务"><a href="#安装成windows服务" class="headerlink" title="安装成windows服务"></a>安装成windows服务</h2><p>自己本地练习的时候呢，每一次都要打开目录，然后输入命令来启动服务，再打开另外一个窗口进行操作，确实是不方便，接下来将redis服务安装成windows服务。<br>命令窗口执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-install redis.windows.conf</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li>启动命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-start</span><br></pre></td></tr></table></figure><ol start="2"><li>停止命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-stop</span><br></pre></td></tr></table></figure><ol start="3"><li>卸载命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-uninstall</span><br></pre></td></tr></table></figure><h2 id="Redis可视化工具RedisDesktopManager"><a href="#Redis可视化工具RedisDesktopManager" class="headerlink" title="Redis可视化工具RedisDesktopManager"></a>Redis可视化工具RedisDesktopManager</h2><p>使用黑窗口操作虽然看起来足够炫酷，但是终究还是不那么方便，因此，需要使用到RDM工具，这块比较简单了就。安装，一路next。<br><img src="http://img.wanglixia.top/redis-windows-install-安装RDM-3-2019110165151.png" alt="redis-windows-install-安装RDM-3-2019110165151"><br>填入连接名，随便填，你认识就行；服务器地址、端口号、密码，点测试连接；<br><img src="http://img.wanglixia.top/redis-windows-install-测试连接-4-2019110165446.png" alt="redis-windows-install-测试连接-4-2019110165446"><br>可以缓存到内容<br><img src="http://img.wanglixia.top/redis-windows-install-连接成功-5-201911018212.png" alt="redis-windows-install-连接成功-5-201911018212"></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.wanglixia.top/redis-logo-2019115132039.jpg&quot; alt=&quot;redis-logo-2019115132039&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Redis是一个开源（BSD许可），内存数据结构存储，用作数据库，缓存和消息代理。 它支持数据结构，如字符串，散列，列表，集合，带有范围查询的排序集，位图，超级日志，带有半径查询和流的地理空间索引。 Redis具有内置复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用性并使用Redis Cluster自动分区。本文简单记录一下windows下redis设置及安装成windows服务。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="windows" scheme="https://www.wanglixia.top/tags/windows/"/>
    
      <category term="redis" scheme="https://www.wanglixia.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>好用的前端响应式框架——Bootstrap</title>
    <link href="https://www.wanglixia.top/bootstrap-study-note.html"/>
    <id>https://www.wanglixia.top/bootstrap-study-note.html</id>
    <published>2019-01-05T07:22:57.000Z</published>
    <updated>2019-01-06T16:03:00.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。<br><img src="http://img.wanglixia.top/bootstrap-201916235849.png" alt="bootstrap-201916235849"><br><a id="more"></a></p><h3 id="Bootstrap的优点："><a href="#Bootstrap的优点：" class="headerlink" title="Bootstrap的优点："></a>Bootstrap的优点：</h3><ul><li>移动设备优先。</li><li>响应式设计。基于bootstrap的网站和系统，能够自适应于台式机、平板电脑和手机。</li><li>容易上手。前置技能：HTML和CSS的基础知识即可。</li><li>浏览器支持比较好。IE、FireFox、Chrome、Opera、Safari等。</li><li>文档比较完善、内置组件比较多，容易定制。</li><li>开源。</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>Bootstrap提供多种使用方式：直接下载Bootstrap并引入；使用BootstrapCDN；包管理工具；npm、RubyGems、Composer、NuGet。这里主要说一下使用第一种方式（直接下载Bootstrap并引入），也是最常见的一种方式，也可以直接使用BootstrapCDN提供的免费CDN加速版本。</p><ul><li>下载版本：<ol><li>下载适用于生产环境的Bootstrap（不包含文档）；</li><li>下载Bootstrap源码（包含文档）；</li><li>Sass 用于快速地在 Rails、Compass 或 只针对 Sass 的项目中引入。</li></ol></li><li>下载链接：<a href="https://v3.bootcss.com/getting-started/#download-composer" target="_blank" rel="noopener">https://v3.bootcss.com/getting-started/#download-composer</a><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3>bootstrap/</li><li>css/<ul><li>bootstrap.css</li><li>bootstrap.min.css</li><li>bootstrap-theme.css</li><li>bootstrap-theme.min.css</li></ul></li><li>js/<ul><li>bootstrap.js</li><li>bootstrap.min.js<h3 id="Bootstrap使用"><a href="#Bootstrap使用" class="headerlink" title="Bootstrap使用"></a>Bootstrap使用</h3>在使用Bootstrap的html模板中进行使用。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap使用和效果预览<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/bootstrap.min.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/bootstrap-theme.min.css"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Bootstrap的相关概念"><a href="#Bootstrap的相关概念" class="headerlink" title="Bootstrap的相关概念"></a>Bootstrap的相关概念</h4><p>Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。<br>前面有说过bootstrap的一个优点，那就是移动设备优先：优先设计更小的宽度，即默认设计是移动设备的样式，再使用媒体查询来设置平板电脑、台式电脑以及大台式电脑。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 超小设备（手机，小于 768px） */</span></span><br><span class="line"><span class="comment">/* Bootstrap 中默认情况下没有媒体查询 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 小型设备（平板电脑，768px 起） */</span></span><br><span class="line">@<span class="keyword">media</span> (min-width: @screen-sm-min) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中型设备（台式电脑，992px 起） */</span></span><br><span class="line">@<span class="keyword">media</span> (min-width: @screen-md-min) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 大型设备（大台式电脑，1200px 起） */</span></span><br><span class="line">@<span class="keyword">media</span> (min-width: @screen-lg-min) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>具体设置及行为见下表：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">超小设备手机（&lt;768px）</th><th style="text-align:left">小型设备平板电脑（≥768px）</th><th style="text-align:left">中型设备台式电脑（≥992px）</th><th style="text-align:left">大型设备台式电脑（≥1200px）</th></tr></thead><tbody><tr><td style="text-align:left">网格行为</td><td style="text-align:left">一直是水平的</td><td style="text-align:left">以折叠开始，断点以上是水平的</td><td style="text-align:left">以折叠开始，断点以上是水平的</td><td style="text-align:left">以折叠开始，断点以上是水平的</td></tr><tr><td style="text-align:left">最大容器宽度</td><td style="text-align:left">None (auto)</td><td style="text-align:left">750px</td><td style="text-align:left">970px</td><td style="text-align:left">1170px</td></tr><tr><td style="text-align:left">Class 前缀</td><td style="text-align:left">.col-xs-</td><td style="text-align:left">.col-sm-</td><td style="text-align:left">.col-md-</td><td style="text-align:left">.col-lg-</td></tr><tr><td style="text-align:left">列数量和</td><td style="text-align:left">12</td><td style="text-align:left">12</td><td style="text-align:left">12</td><td style="text-align:left">12</td></tr><tr><td style="text-align:left">最大列宽</td><td style="text-align:left">Auto</td><td style="text-align:left">60px</td><td style="text-align:left">78px</td><td style="text-align:left">95px</td></tr><tr><td style="text-align:left">间隙宽度</td><td style="text-align:left">30px（一个列的每边分别 15px）</td><td style="text-align:left">30px（一个列的每边分别 15px）</td><td style="text-align:left">30px（一个列的每边分别 15px）</td><td style="text-align:left">30px（一个列的每边分别 15px）</td></tr><tr><td style="text-align:left">可嵌套</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">偏移量</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">列排序</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td></tr></tbody></table><h4 id="Bootstrap怎么用？"><a href="#Bootstrap怎么用？" class="headerlink" title="Bootstrap怎么用？"></a>Bootstrap怎么用？</h4><p>在一个div中的class中定义col-<em>-</em>，第一个星号的值范围是[xs,sm,md,lg] ，第二个星号的值范围是1-12；因此设置的时候需要注意数值是否规范。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在一个div中的class中定义col-*-*，第一个星号的值范围是[xs,sm,md,lg] ，第二个星号的值范围是1-12--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-*-*"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-*-*"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="Bootstrap布局组件"><a href="#Bootstrap布局组件" class="headerlink" title="Bootstrap布局组件"></a>Bootstrap布局组件</h4><ul><li>Bootstrap 字体图标</li><li>Bootstrap 下拉菜单</li><li>Bootstrap 按钮组</li><li>Bootstrap 按钮下拉菜单</li><li>Bootstrap 输入框组</li><li>Bootstrap 导航元素</li><li>Bootstrap 导航栏</li><li>Bootstrap 面包屑导航</li><li>Bootstrap 分页</li><li>Bootstrap 标签</li><li>Bootstrap 徽章</li><li>Bootstrap 超大屏幕</li><li>Bootstrap 页面标题</li><li>Bootstrap 缩略图</li><li>Bootstrap 警告</li><li>Bootstrap 进度条</li><li>Bootstrap 多媒体对象</li><li>Bootstrap 列表组</li><li>Bootstrap 面板</li><li>Bootstrap Wells<h4 id="Bootstrap插件"><a href="#Bootstrap插件" class="headerlink" title="Bootstrap插件"></a>Bootstrap插件</h4></li><li>Bootstrap 过渡效果</li><li>Bootstrap 模态框</li><li>Bootstrap 下拉菜单</li><li>Bootstrap 滚动监听</li><li>Bootstrap 标签页</li><li>Bootstrap 提示工具</li><li>Bootstrap 弹出框</li><li>Bootstrap 警告框</li><li>Bootstrap 按钮</li><li>Bootstrap 折叠</li><li>Bootstrap 轮播</li><li>Bootstrap 附加导航<h4 id="Bootstrap常用插件"><a href="#Bootstrap常用插件" class="headerlink" title="Bootstrap常用插件"></a>Bootstrap常用插件</h4></li><li>表单验证插件 bootstrapValidator</li><li>Messenger 弹框组件库<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3>文档上提供的BootstrapDialog模态框组件的实现比较繁琐，因此可以在网上找相关插件处理。<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3></li><li>Bootstrap官网：<a href="http://www.bootcss.com/" target="_blank" rel="noopener">http://www.bootcss.com/</a></li><li>Bootstrap官方文档：<a href="https://v3.bootcss.com/components/" target="_blank" rel="noopener">https://v3.bootcss.com/components/</a><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3>在学习过程中，经常在<strong>菜鸟教程</strong><a href="http://www.runoob.com/" target="_blank" rel="noopener">http://www.runoob.com/</a>查阅资料，表示感谢。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。&lt;br&gt;&lt;img src=&quot;http://img.wanglixia.top/bootstrap-201916235849.png&quot; alt=&quot;bootstrap-201916235849&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="前端" scheme="https://www.wanglixia.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Bootstrap" scheme="https://www.wanglixia.top/tags/Bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>mybatis常见错误记录</title>
    <link href="https://www.wanglixia.top/mybatis%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95.html"/>
    <id>https://www.wanglixia.top/mybatis常见错误记录.html</id>
    <published>2019-01-03T02:02:28.000Z</published>
    <updated>2019-01-04T17:24:56.252Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Mybatis使用过程中，常见的一些问题汇总记录。<br><a id="more"></a></p><h3 id="1-Mybatis执行SQL，查出来的比使用PL-SQL等工具查出来的记录多。"><a href="#1-Mybatis执行SQL，查出来的比使用PL-SQL等工具查出来的记录多。" class="headerlink" title="1. Mybatis执行SQL，查出来的比使用PL/SQL等工具查出来的记录多。"></a>1. Mybatis执行SQL，查出来的比使用PL/SQL等工具查出来的记录多。</h3><ul><li>问题描述：由于查询要使用到not in，因此 not in ()括号里面的东西自己使用了前端拼接传值，传值格式为’’,’’</li><li>问题处理：在Mapper.xml中使用了#{}，这块涉及到#{}和${}的区别。替换成${} 就好了。</li></ul><h3 id="2-MyBatis-mapper文件中的变量引用方式-与-的差别"><a href="#2-MyBatis-mapper文件中的变量引用方式-与-的差别" class="headerlink" title="2. MyBatis mapper文件中的变量引用方式#{}与${}的差别"></a>2. MyBatis mapper文件中的变量引用方式#{}与${}的差别</h3><p>默认情况下,使用#{}语法,MyBatis会产生PreparedStatement语句中，并且安全的设置PreparedStatement参数，这个过程中MyBatis会进行必要的安全检查和转义。<br>示例1：<br>执行SQL：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span> = #&#123;employeeName&#125;</span><br></pre></td></tr></table></figure></p><p>参数：<code>employeeName</code>传入值为：<code>Smith</code><br>解析后执行的SQL：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span> = ?</span><br></pre></td></tr></table></figure></p><p>执行SQL：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span> = $&#123;employeeName&#125;</span><br></pre></td></tr></table></figure></p><p>参数：<code>employeeName</code>传入值为：<code>Smith</code><br>解析后执行的SQL：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span> = Smith</span><br></pre></td></tr></table></figure></p><p>综上所述、${}方式会引发SQL注入的问题、同时也会影响SQL语句的预编译，所以从安全性和性能的角度出发，能使用#{}的情况下就不要使用${}<br>${}的使用场景：<br>有时候可能需要直接插入一个不做任何修改的字符串到SQL语句中。这时候应该使用${}语法。<br>比如，动态SQL中的字段名，如：<code>ORDER BY ${columnName}，not in ${items}</code><br>注意：当使用${}参数作为字段名或表名时、需指定statementType为“STATEMENT”，如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryMetaList"</span> <span class="attr">resultType</span>=<span class="string">"Map"</span> <span class="attr">statementType</span>=<span class="string">"STATEMENT"</span>&gt;</span></span><br><span class="line">    Select * from emp where name = $&#123;employeeName&#125; ORDER BY $&#123;columnName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-ssm-web项目启动报错（一）"><a href="#3-ssm-web项目启动报错（一）" class="headerlink" title="3. ssm-web项目启动报错（一）"></a>3. ssm-web项目启动报错（一）</h3><blockquote><p>Could not resolve type alias ‘map ‘. Cause: java.lang.ClassNotFoundException: Cannot find class: map</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByCode"</span> <span class="attr">resultType</span>=<span class="string">"com.lucifer.pojo.BaseParams"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.map"</span>&gt;</span></span><br><span class="line">    SELECT BP.ID,BP.NAME FROM BASE_PARAMS BP WHERE BP.DOMAIN=#&#123;domain&#125; AND BP.IS_CANCEL='N'</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>处理方式：把resultType改为resultMap，把parameterType改为parameterMap，重新发布并运行。</p><h3 id="4-ssm-web项目启动报错（二）"><a href="#4-ssm-web项目启动报错（二）" class="headerlink" title="4. ssm-web项目启动报错（二）"></a>4. ssm-web项目启动报错（二）</h3><blockquote><p>org.mybatis.spring.transaction.SpringManagedTransaction - JDBC Connection [<strong><em>**</em></strong>] will not be managed by Spring</p></blockquote><p>处理方式：</p><p><img src="http://img.wanglixia.top/mybatis-1-20191504549.png" alt="mybatis-1-20191504549"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Mybatis使用过程中，常见的一些问题汇总记录。&lt;br&gt;
    
    </summary>
    
      <category term="错误" scheme="https://www.wanglixia.top/categories/%E9%94%99%E8%AF%AF/"/>
    
    
      <category term="mybatis" scheme="https://www.wanglixia.top/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>RxJava</title>
    <link href="https://www.wanglixia.top/rxjava.html"/>
    <id>https://www.wanglixia.top/rxjava.html</id>
    <published>2019-01-02T14:10:31.000Z</published>
    <updated>2019-01-03T13:44:41.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><p>当被观察者(Observable)的生成速度大于观察者(Observer)的处理速度会出现 Backpressure 现象(只有在异步环境下会发生).<br>会抛出 MissingBackpressureException 异常信息<br><a id="more"></a></p><h2 id="Hot-and-Cold-Observables"><a href="#Hot-and-Cold-Observables" class="headerlink" title="Hot and Cold Observables"></a>Hot and Cold Observables</h2><ul><li>Cold Observables：当被订阅后才开始发送事件的Observable(每个Subscriber都能接收到完整的事件)</li><li>Hot Observables:  不管有没有被订阅,都会去发送事件的 Observable</li></ul><p>Hot Observable 是不支持背压的,Cold Observable 有一部分并不支持背压(比如interval，timer等操作符创建的Observable)<br>rxJava2.0 已经解决了这个问题(?:Observable,有的支持背压,有的不支持)</p><p>cold observable 相当于响应式拉(就是observer处理完了一个事件就从observable拉取下一个事件),hot observable通常不能很好的处理响应式拉模型,例如使用onBackpressureBuffer或者onBackpressureDrop 操作符,和其他操作符比<br>如operators, throttling, buffers, or windows.</p><p>observeOn这个操作符内部有一个缓冲区，默认长度是16.经常用到的Observable.create 就是 Cold Observable,而 just, range, timer 和 from 这些创建的同样是 Cold Observable.我们一般使用的都是Cold Observable,除非特殊需求,才会使用Hot Observable</p><h2 id="背压操作符"><a href="#背压操作符" class="headerlink" title="背压操作符"></a>背压操作符</h2><p>rxJava1.X 针对不支持背压提供的操作符有：sample(),throttleLast(),throttleFirst(),throttleWithTimeout(),debounce(),onBackpressurebuffer(),onBackpressureDrop()</p><h2 id="RxJava1-x-vs-RxJava2-x"><a href="#RxJava1-x-vs-RxJava2-x" class="headerlink" title="RxJava1.x vs RxJava2.x"></a>RxJava1.x vs RxJava2.x</h2><ul><li>2.x 发送事件时不能传 null,否则会抛出空指针异常</li><li>2.x 中 Observable 不再支持背压, 用 Flowable 来支持背压</li><li>线程调度方面 2.x 取消 Schedulers.immediate()</li></ul><h2 id="RxJava2-Backpressure"><a href="#RxJava2-Backpressure" class="headerlink" title="RxJava2 Backpressure"></a>RxJava2 Backpressure</h2><p>Observable拆分成了新的 Observable 和 Flowable,Observable 不具备处理背压能力,Flowable 解决了背压问题,Backpressure 只在异步情况下产生,RxJava2 的处理策略仅仅是对观察者接收事件的处理</p><p>1.ERROR<br>产生背压问题会抛出 MissingBackpressureException 异常信息<br>在异步调用时,RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据,缓存池的默认大小为128,即只能<br>缓存128个事件.无论request()中传入的数字比128大或小,缓存池中在刚开始都会存入128个事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;&gt;(),BackpressureStrategy.ERROR)</span><br><span class="line">.subscribe(new Subscriber());</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>BUFFER<br>把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池，支持存很多很多的数据,比较消耗内存</p></li><li><p>DROP  LATEST<br>DROP 丢弃事件,LATEST使消费者能够接收到生产者产生的最后一个事件</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RxJava&quot;&gt;&lt;a href=&quot;#RxJava&quot; class=&quot;headerlink&quot; title=&quot;RxJava&quot;&gt;&lt;/a&gt;RxJava&lt;/h2&gt;&lt;p&gt;当被观察者(Observable)的生成速度大于观察者(Observer)的处理速度会出现 Backpressure 现象(只有在异步环境下会发生).&lt;br&gt;会抛出 MissingBackpressureException 异常信息&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="RxJava" scheme="https://www.wanglixia.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>记使用hexo搭建个人博客-报错集锦</title>
    <link href="https://www.wanglixia.top/hexo-coding-github-%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A6.html"/>
    <id>https://www.wanglixia.top/hexo-coding-github-报错集锦.html</id>
    <published>2018-12-28T17:47:16.000Z</published>
    <updated>2019-01-03T15:57:14.408Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;使用hexo+github/coding+next搭建个人博客过程中遇到的一些问题集中整理，包括：</p><ul><li>报错一：<code>TypeError: Cannot set property ‘lastIndex’ of undefined</code></li><li>报错二：<code>Permission denied (publickey).</code></li><li>报错三：<code>Error: ERROR: Repository not found. fatal: Could not read from remote repository.</code><a id="more"></a></li></ul><h4 id="报错一：TypeError-Cannot-set-property-‘lastIndex’-of-undefined"><a href="#报错一：TypeError-Cannot-set-property-‘lastIndex’-of-undefined" class="headerlink" title="报错一：TypeError: Cannot set property ‘lastIndex’ of undefined"></a>报错一：TypeError: Cannot set property ‘lastIndex’ of undefined</h4><p>问题描述：使用<code>hexo g</code> 报错</p><blockquote><p>TypeError: Cannot set property ‘lastIndex’ of undefined</p></blockquote><p><img src="http://img.wanglixia.top/hexo-coding-github-%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A61.png" alt="hexo-coding-github-报错集锦"><br>问题处理：在hexo中的<code>_config.yml</code> 文件中的高亮功能设置错了，不是主题的<code>_config.yml</code>，其中的 auto_detect 应该设置为 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure></p><p>改过之后再执行就好了。</p><h4 id="报错二：-Permission-denied-publickey"><a href="#报错二：-Permission-denied-publickey" class="headerlink" title="报错二： Permission denied (publickey)."></a>报错二： Permission denied (publickey).</h4><p>问题处理：<br>第一步：创建SSH Key。windows下的目录<code>C:\Users\用户名.ssh</code>，看看有没有.ssh目录，，如果有，再看看这个目录下有没有<code>id_rsa<code>和</code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"ne_lucifer@163.com"</span></span><br></pre></td></tr></table></figure></p><p>你需要把邮件地址换成你自己的邮件地址，然后点击回车，使用默认值即可。<br>第二步：登录Github（登录后路径<code><a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a></code>）或者Coding(登录后路径<code></code>)，按如下步骤操作，用记事本打开<code>id_rsa.pub</code>，全选，把里面的内容粘贴到公钥内容里，title随便起一个<br><img src="http://img.wanglixia.top/hexo-coding-github-%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A62-1.png" alt="hexo-coding-github-报错集锦2-1"><br><img src="http://img.wanglixia.top/hexo-coding-github-%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A62-2.png" alt="hexo-coding-github-报错集锦2-2"></p><h4 id="报错三：-Error-ERROR-Repository-not-found-fatal-Could-not-read-from-remote-repository"><a href="#报错三：-Error-ERROR-Repository-not-found-fatal-Could-not-read-from-remote-repository" class="headerlink" title="报错三： Error: ERROR: Repository not found. fatal: Could not read from remote repository."></a>报错三： Error: ERROR: Repository not found. fatal: Could not read from remote repository.</h4><p>问题描述：使用<code>hexo d</code>部署项目到pages服务时报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: ERROR: Repository not found.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (F:\WorkSpaces\hexo\blog\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at ChildProcess.emit (events.js:182:13)</span><br><span class="line">    at ChildProcess.cp.emit (F:\WorkSpaces\hexo\blog\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:962:16)</span><br><span class="line">    at Socket.stream.socket.on (internal/child_process.js:381:11)</span><br><span class="line">    at Socket.emit (events.js:182:13)</span><br><span class="line">    at Pipe._handle.close (net.js:606:12)</span><br></pre></td></tr></table></figure></p><p>查看远端有没有这个分支；<br>使用<code>ssh -T <a href="mailto:git@git.coding.net" target="_blank" rel="noopener">git@git.coding.net</a></code>命令，会出现下面信息，输入yes然后回车即可部署。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;git.coding.net (118.25.166.124)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:这块是一串编码.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;使用hexo+github/coding+next搭建个人博客过程中遇到的一些问题集中整理，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;报错一：&lt;code&gt;TypeError: Cannot set property ‘lastIndex’ of undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;报错二：&lt;code&gt;Permission denied (publickey).&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;报错三：&lt;code&gt;Error: ERROR: Repository not found. fatal: Could not read from remote repository.&lt;/code&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="hexo" scheme="https://www.wanglixia.top/tags/hexo/"/>
    
      <category term="github" scheme="https://www.wanglixia.top/tags/github/"/>
    
      <category term="coding" scheme="https://www.wanglixia.top/tags/coding/"/>
    
      <category term="next" scheme="https://www.wanglixia.top/tags/next/"/>
    
      <category term="gitalk" scheme="https://www.wanglixia.top/tags/gitalk/"/>
    
      <category term="报错" scheme="https://www.wanglixia.top/tags/%E6%8A%A5%E9%94%99/"/>
    
  </entry>
  
  <entry>
    <title>记使用hexo搭建个人博客（三）</title>
    <link href="https://www.wanglixia.top/hexo-coding-github-3.html"/>
    <id>https://www.wanglixia.top/hexo-coding-github-3.html</id>
    <published>2018-12-28T16:43:12.000Z</published>
    <updated>2019-01-11T17:04:35.679Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;使用hexo+next+github/coding+gitalk添加博客评论系统,以及hexo+next+码云+issue，这里使用的是next主题，如有问题，可以在博客下方评论。本文内容如下：</p><ul><li>使用gitalk为博客添加评论功能、</li><li>vscode 使用七牛云做图床、 </li><li>Hexo Next主题SEO优化、</li><li>Hexo 添加RSS订阅<a id="more"></a><h2 id="next主题添加gitalk"><a href="#next主题添加gitalk" class="headerlink" title="next主题添加gitalk"></a>next主题添加gitalk</h2></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在使用gitalk作为评论系统之前，需要在github上注册新的应用； <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">注册GitHub应用链接</a>。<br>按如下描述填写:<br><img src="http://img.wanglixia.top/hexo-coding-github-3-github%E6%B3%A8%E5%86%8C%E5%BA%94%E7%94%A8.png" alt="github注册应用"><br>填写完成后，点击绿色按钮，跳转到一下页面，<br>可以看到<code>Client ID</code>和<code>Client Secret</code>，后面会用到。<br><img src="http://img.wanglixia.top/hexo-coding-github-3-github%E6%B3%A8%E5%86%8C%E5%BA%94%E7%94%A8%E4%BF%9D%E5%AD%98%E5%90%8E.png" alt="github注册应用保存后跳转的页面"><br>在项目目录下执行如下命令<code>npm install gitalk –save</code> 安装<code>gitalk</code>；</p><h3 id="修改的内容"><a href="#修改的内容" class="headerlink" title="修改的内容"></a>修改的内容</h3><h4 id="新建gitalk-swig；"><a href="#新建gitalk-swig；" class="headerlink" title="新建gitalk.swig；"></a>新建<code>gitalk.swig</code>；</h4><p>路径<code>themes/next/layout/_third-party/comments/gitalk.swig</code>，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><h4 id="修改comments-swig"><a href="#修改comments-swig" class="headerlink" title="修改comments.swig"></a>修改<code>comments.swig</code></h4><p>路径<code>themes/next/layout/_partials/comments.swig</code>，在最后一个<code>div</code>里面加上如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="修改index-swig"><a href="#修改index-swig" class="headerlink" title="修改index.swig"></a>修改<code>index.swig</code></h4><p>路径<code>themes/next/layout/_third-party/comments/index.swig</code>，在最后一行加上如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &apos;gitalk.swig&apos; %&#125;</span><br></pre></td></tr></table></figure></p><h4 id="新建gitalk-styl"><a href="#新建gitalk-styl" class="headerlink" title="新建gitalk.styl"></a>新建<code>gitalk.styl</code></h4><p>路径<code>themes/next/source/css/_common/components/third-party/gitalk.styl</code>，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.gt-header a, .gt-comments a, .gt-popup a</span><br><span class="line">  border-bottom: none;</span><br><span class="line">.gt-container .gt-popup .gt-action.is--active:before</span><br><span class="line">  top: 0.7em;</span><br></pre></td></tr></table></figure></p><h4 id="修改third-party-styl"><a href="#修改third-party-styl" class="headerlink" title="修改third-party.styl"></a>修改<code>third-party.styl</code></h4><p>路径<code>themes/next/source/css/_common/components/third-party/gitalk.styl</code>，在最后一行加上如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;gitalk&quot;;</span><br></pre></td></tr></table></figure></p><h4 id="修改文件-config-yml"><a href="#修改文件-config-yml" class="headerlink" title="修改文件_config.yml"></a>修改文件<code>_config.yml</code></h4><p>路径<code>themes/next/_config.yml</code>，注意是主题的配置文件，增加内容如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  githubID:</span> <span class="string">nelucifer</span>  <span class="comment"># 例：nelucifer</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">nelucifer.github.io</span>   <span class="comment"># 存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名） 例：nelucifer.github.io </span></span><br><span class="line"><span class="attr">  ClientID:</span> <span class="string">这块填注册Github应用成功之后的ClientID</span></span><br><span class="line"><span class="attr">  ClientSecret:</span> <span class="string">注册Github应用成功之后的ClientSecret</span></span><br><span class="line">  <span class="comment">#owner: 'Github 用户名',</span></span><br><span class="line"><span class="attr">  adminUser:</span> <span class="string">['nelucifer']</span> <span class="comment">#指定可初始化评论账户，Github仓库的管理员，可以有多个</span></span><br><span class="line"><span class="attr">  distractionFreeMode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#id: 'window.location.pathname' #页面的唯一标识，gitalk根据这个标识自动创建的issue的标签,此处使用页面的相对路径作为标识</span></span><br></pre></td></tr></table></figure></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>&emsp;&emsp;在使用gitalk作为评论系统的时候，参考了以下文章，特此添加链接，表示感谢：</p><ul><li><a href="https://blog.csdn.net/hyb612/article/details/78299971" target="_blank" rel="noopener">hexo 博客next主题集成gitment或者gitalk评论系统</a><br></li><li><a href="https://blog.csdn.net/dataiyangu/article/details/84961965" target="_blank" rel="noopener">hexo next主题深度优化(五)，评论系统换成gittalk</a></li></ul><h2 id="vscode-七牛云"><a href="#vscode-七牛云" class="headerlink" title="vscode + 七牛云"></a>vscode + 七牛云</h2><p>现在使用七牛云做图床需要已经备案的域名，测试域名不能用啦。</p><h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><ul><li>下载vscode，<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">这儿是下载链接</a></li><li>七牛云，<a href="https://developer.qiniu.com/" target="_blank" rel="noopener">传送门</a><h4 id="安装七牛云插件"><a href="#安装七牛云插件" class="headerlink" title="安装七牛云插件"></a>安装七牛云插件</h4></li><li>安装插件：<code>qiniu-upload-image</code></li><li>文件&gt;首选项&gt;设置，在右侧setting.json填写自己的配置覆盖默认配置。配置文件如下，使用的配置是七牛云里面的【密钥管理】：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 一个有效的七牛 AccessKey 签名授权。</span><br><span class="line">  &quot;qiniu.access_key&quot;: &quot;密钥管理里面的AK&quot;,</span><br><span class="line"></span><br><span class="line">  // 七牛图片上传空间。</span><br><span class="line">  &quot;qiniu.bucket&quot;: &quot;weyoung-pub&quot;,</span><br><span class="line"></span><br><span class="line">  // 七牛图床域名。</span><br><span class="line">  &quot;qiniu.domain&quot;: &quot;自己配置的图床域名，使用二级域名就行&quot;,</span><br><span class="line"></span><br><span class="line">  // 七牛图片上传工具开关</span><br><span class="line">  &quot;qiniu.enable&quot;: true,</span><br><span class="line"></span><br><span class="line">  // 七牛图片上传路径，参数化命名。</span><br><span class="line">  &quot;qiniu.remotePath&quot;: &quot;$&#123;fileName&#125;-$&#123;dateTime&#125;&quot;,</span><br><span class="line"></span><br><span class="line">  // 一个有效的七牛 SecretKey 签名授权。</span><br><span class="line">  &quot;qiniu.secret_key&quot;: &quot;密钥管理里面的SK&quot;,</span><br><span class="line">  &quot;files.autoSave&quot;: &quot;afterDelay&quot;,</span><br><span class="line">  &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\Windows\\System32\\cmd.exe&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用快捷键"><a href="#使用快捷键" class="headerlink" title="使用快捷键"></a>使用快捷键</h4><blockquote><p>粘贴图片路径上传：SHIFT + P<br>直接选择图片上传：SHIFT + O</p></blockquote><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>Ctrl+P 输入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext install qiniu-upload-image</span><br></pre></td></tr></table></figure></p><h4 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h4><h2 id="Hexo-Next-主题SEO优化"><a href="#Hexo-Next-主题SEO优化" class="headerlink" title="Hexo Next 主题SEO优化"></a>Hexo Next 主题SEO优化</h2><h3 id="SEO-？"><a href="#SEO-？" class="headerlink" title="SEO ？"></a>SEO ？</h3><p>汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。</p><h3 id="针对百度搜索引擎的优化"><a href="#针对百度搜索引擎的优化" class="headerlink" title="针对百度搜索引擎的优化"></a>针对百度搜索引擎的优化</h3><h4 id="1-添加百度sitemap，生成sitemap文件"><a href="#1-添加百度sitemap，生成sitemap文件" class="headerlink" title="1. 添加百度sitemap，生成sitemap文件"></a>1. 添加百度sitemap，生成sitemap文件</h4><p>安装两个插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save-dev</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save-dev</span><br></pre></td></tr></table></figure></p><p>上面的是传统的sitemap，下面的是百度专有的sitemap。<br>测试是否安装成功。使用命令<code>hexo s</code>本地预览。<br>本地预览：[<a href="http://localhost:4000/sitemap.xml]http://localhost:4000/sitemap.xml" target="_blank" rel="noopener">http://localhost:4000/sitemap.xml]http://localhost:4000/sitemap.xml</a> 和 [<a href="http://localhost:4000/baidusitemap.xml]http://localhost:4000/baidusitemap.xml" target="_blank" rel="noopener">http://localhost:4000/baidusitemap.xml]http://localhost:4000/baidusitemap.xml</a> 显示sitemap文件内容。</p><h4 id="2-注册百度搜索资源工具"><a href="#2-注册百度搜索资源工具" class="headerlink" title="2. 注册百度搜索资源工具"></a>2. 注册百度搜索资源工具</h4><p>地址：<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">https://ziyuan.baidu.com/</a><br>添加网站之后，需要验证，验证方式有<code>文件验证</code>、<code>HTML标签验证</code>、<code>CNAME验证</code>。<br>网上的例子：使用<code>文件验证</code>进行验证。</p><ul><li>下载验证文件，放到博客项目的<code>source</code>文件夹下，使用<code>hexo g -d</code>，部署到自己的网站上；</li><li>部署之后，在站长工具页面点击验证，能够访问证明验证成功；</li><li>然后点击【完成验证】按钮，为保持验证通过的状态,成功验证后请不要删除HTML文件。</li></ul><p><strong>我使用这个验证失败，hexo会为文件加上一些样式，验证好几次验证不通过</strong></p><p>使用<code>HTML标签验证</code>进行验证。我使用的是<code>Hexo + NexT</code>。</p><ul><li>在<code>themes/next/layout/_partials/head.swig</code>文件中，修改meta标签为站长工具里面给出的标签。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.baidu_site_verification %&#125;</span><br><span class="line">  &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;这块修改&quot; /&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><p>或者在 <code>themes/next/_config.yml</code> 添加或者修改，<strong>注意格式</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百度搜索引擎优化</span></span><br><span class="line"><span class="attr">baidu_site_verification:</span> <span class="string">站长工具里面给出的标签</span></span><br></pre></td></tr></table></figure><ul><li>在<code>themes/next/_config.yml</code>中将<figure class="highlight plain"><figcaption><span>false``` 改为<code>true</code></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 使用&lt;code&gt;hexo g -d&lt;/code&gt;，部署到自己的网站上，如果不清楚部署的可以看前两篇文章；</span><br><span class="line">* 然后点击【完成验证】按钮，等待百度的审核结果</span><br><span class="line"></span><br><span class="line">#### 3. 添加robots，方便搜索蜘蛛进行检索</span><br><span class="line">&amp;emsp;&amp;emsp;百度百科：robots是网站跟爬虫间的协议，用简单直接的txt格式文本方式告诉对应的爬虫被允许的权限，也就是说robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</span><br><span class="line"></span><br><span class="line">新建&lt;code&gt;robots.txt&lt;/code&gt;文件，添加以下文件内容，把&lt;code&gt;robots.txt&lt;/code&gt;放在的&lt;code&gt;source&lt;/code&gt;文件下。</span><br><span class="line">文件内容：</span><br></pre></td></tr></table></figure></li></ul><h1 id="hexo-robots-txt"><a href="#hexo-robots-txt" class="headerlink" title="hexo robots.txt"></a>hexo robots.txt</h1><p>User-agent: * Allow: /<br>Allow: /archives/<br>Allow: /about/<br>Disallow: /js/<br>Disallow: /css/<br>Disallow: /fonts/<br>Disallow: /images/</p><p>Sitemap: <a href="http://www.wanglixia.top/sitemap.xml">http://www.wanglixia.top/sitemap.xml</a><br>Sitemap: <a href="http://www.wanglixia.top/baidusitemap.xml">http://www.wanglixia.top/baidusitemap.xml</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在百度站长工具-【链接提交】中填写数据文件地址并提交。</span><br><span class="line"></span><br><span class="line">#### 4. 优化结构 </span><br><span class="line">这个我不懂，参考资料: 作者：浪子燕青啦啦啦 [HEXO SEO 高级优化](https://blog.csdn.net/lzy98/article/details/81140704)</span><br><span class="line">seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：</span><br><span class="line">```yml</span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://www.wanglixia.top/  #你的域名</span><br><span class="line">root: /</span><br><span class="line">#permalink: :year/:month/:day/:title/  为了利于SEO，改为以下方式</span><br><span class="line">permalink: :title.html</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p><p>首页标题优化，SEO最重要的是你的标题，一般搜索都是搜索你的标题，更改<code>index.swig</code>文件(<code>your-hexo-site\themes\next\layout</code>);</p><h2 id="您的站点有链接未通过https检验"><a href="#您的站点有链接未通过https检验" class="headerlink" title="您的站点有链接未通过https检验"></a>您的站点有链接未通过https检验</h2><p>因为一直使用的是http，百度验证需要使用https。我是使用coding+github双线部署的；</p><ul><li><p>coding 设置强制https访问<br>打开项目，【代码】-&gt;【Pages服务】-&gt;【强制 HTTPS 访问】</p></li><li><p>github 设置强制https访问<br>打开项目，【setting】-&gt;【Enforce HTTPS】的勾打上；<br>完成；访问一下，看下有没有变化啦！</p></li></ul><h2 id="Hexo添加RSS订阅"><a href="#Hexo添加RSS订阅" class="headerlink" title="Hexo添加RSS订阅"></a>Hexo添加RSS订阅</h2><h3 id="安装feed插件"><a href="#安装feed插件" class="headerlink" title="安装feed插件"></a>安装feed插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><p>在项目根目录的<code>_config.yml</code>添加内容：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">    <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="attr">feed:</span>                       <span class="comment"># 实现博客订阅功能</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>使用<code>hexo g -d</code>生成并部署。<br>使用方法：邮件中【新建订阅】，我的订阅地址为：<a href="https://www.wanglixia.top/atom.xml">https://www.wanglixia.top/atom.xml</a>，如图：<br><img src="http://img.wanglixia.top/hexo-coding-github-3-添加RSS订阅-201911123752.png" alt="hexo-coding-github-3-添加RSS订阅-201911123752"></p><p>完成</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;使用hexo+next+github/coding+gitalk添加博客评论系统,以及hexo+next+码云+issue，这里使用的是next主题，如有问题，可以在博客下方评论。本文内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用gitalk为博客添加评论功能、&lt;/li&gt;
&lt;li&gt;vscode 使用七牛云做图床、 &lt;/li&gt;
&lt;li&gt;Hexo Next主题SEO优化、&lt;/li&gt;
&lt;li&gt;Hexo 添加RSS订阅
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="hexo" scheme="https://www.wanglixia.top/tags/hexo/"/>
    
      <category term="github" scheme="https://www.wanglixia.top/tags/github/"/>
    
      <category term="coding" scheme="https://www.wanglixia.top/tags/coding/"/>
    
      <category term="next" scheme="https://www.wanglixia.top/tags/next/"/>
    
      <category term="gitalk" scheme="https://www.wanglixia.top/tags/gitalk/"/>
    
      <category term="gitee" scheme="https://www.wanglixia.top/tags/gitee/"/>
    
      <category term="码云" scheme="https://www.wanglixia.top/tags/%E7%A0%81%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>npm常用命令</title>
    <link href="https://www.wanglixia.top/npm-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>https://www.wanglixia.top/npm-常用命令.html</id>
    <published>2018-12-28T05:19:16.000Z</published>
    <updated>2019-01-03T15:34:29.674Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp; 使用npm的时候，有一些命令及配置常用到，记录。</p><a id="more"></a><h3 id="npm修改源"><a href="#npm修改源" class="headerlink" title="npm修改源"></a>npm修改源</h3><p>&emsp;&emsp;使用npm在npm install时，速度特别慢，因此修改npm的数据源<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>修改后，即可进行下载啦，速度快了好多~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp; 使用npm的时候，有一些命令及配置常用到，记录。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="笔记" scheme="https://www.wanglixia.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="npm" scheme="https://www.wanglixia.top/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记之陀氏-穷人的美德</title>
    <link href="https://www.wanglixia.top/%E7%9C%8B%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%99%80%E6%B0%8F-%E7%A9%B7%E4%BA%BA%E7%9A%84%E7%BE%8E%E5%BE%B7.html"/>
    <id>https://www.wanglixia.top/看书笔记之陀氏-穷人的美德.html</id>
    <published>2018-08-20T13:54:08.000Z</published>
    <updated>2019-01-03T15:33:53.083Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;陀氏的《穷人的美德》，摘部分内容于此文中。</p><a id="more"></a><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="穷人的美德就是会赚钱"><a href="#穷人的美德就是会赚钱" class="headerlink" title="穷人的美德就是会赚钱"></a>穷人的美德就是会赚钱</h4><ul><li>穷人最重要的美德就是会赚钱，道德就是一个人不该成为其他人的累赘 。</li><li>要爱别人，首先爱自己，因为世界上的一切都是以个人利益为基础的。</li><li>有几个人的表现特别突出，自然招来一些流言蜚语。因为没有流言蜚语，世界就无法存在，千百万人就会像苍蝇一样，因为寂寞无聊而死去。</li></ul><h4 id="用千万件好事去抵一桩小罪"><a href="#用千万件好事去抵一桩小罪" class="headerlink" title="用千万件好事去抵一桩小罪"></a>用千万件好事去抵一桩小罪</h4><ul><li>命定的事总是会实现的，有价值的人将占有他应有的位置，而无价值的人将永远躲进小胡同，躲进他肮脏的小胡同，他喜爱而且正适合于他的小胡同，并且就在那污秽和臭气中，心甘情愿而且愉快地结束他的生命。</li><li>我们每个人都应该对世上一切人和一切事物负责，这一点是毫无疑义的，这不但是因为大家都参与了整个世界的罪恶，也是因为个人本来就应该为世上的一切人和一切事物负责。</li><li>在这种放荡生活里至少有一种固定不变的东西，它甚至是以天性为基础，而不是为幻想所左右的，它犹如血液中永不熄灭的炭火，永远燃烧着，还要燃烧很久很久，随着年龄的增长，或许也不能让它很快熄灭。</li></ul><h4 id="一时糊涂与意志衰退"><a href="#一时糊涂与意志衰退" class="headerlink" title="一时糊涂与意志衰退"></a>一时糊涂与意志衰退</h4><h4 id="天才人物与犯罪的权利"><a href="#天才人物与犯罪的权利" class="headerlink" title="天才人物与犯罪的权利"></a>天才人物与犯罪的权利</h4><ul><li>总而言之，我得出结论，所有这些人，不仅是那些伟大的，就连那些稍微越出常轨的人，也就是说，就连那些稍微能提出点儿什么新见解的人，就其天性来说，必须是罪人–当然，只是在一定程度上，不然，他们就难以越出常轨；而让他们循规蹈矩，不越雷池一步，他们当然不会同意，这又是由于他们的天性，而照我看，他们甚至有责任不同意。</li><li>按照自然规律，人一般可以分作两类：一类是低级的（平凡的），也可以这么说吧。仅仅是一种繁殖同类的材料；另一类是名副其实的人，也就是有天赋或天才，能在自己的社会上发表新见解的人。……第一类人永远是当代的主人，第二类人却是未来的主人。第一类人保全世界，增加人的数量；第二类人则推动世界向前发展，引导它达到自己的目的。无论是这一类人，还是那一类人，都有完全同等的生存权利。</li></ul><h4 id="我杀死的只是原则"><a href="#我杀死的只是原则" class="headerlink" title="我杀死的只是原则"></a>我杀死的只是原则</h4><ul><li>一般说，有新思想的人，即使只是稍微能发表某种新见解的人，通常是生得很少的，甚至少得出奇。明确的只有一点：必须有某种自然法则来正确无误地确定人的出生规律，正确无误地确定分类和区分他们的规律。</li><li>对于一个知识全面、思想深刻的人，痛苦是必然的，既有精神上的痛苦，也有肉体上的痛苦，我觉得，真正的伟人应该察觉到人世间极大地忧虑。</li><li>……“单就这一点来说，我就是一只虱子，因为，第一，现在我认为我是只虱子；第二，因为整整一个月来，我一直在打搅仁慈的上帝，请他作证，说是，我这么做不是为了自己肉体上的享受和满足自己的淫欲，而是有一个让人感到高兴的崇高目的–哈–哈！… …”</li></ul><h4 id="谁能敢作敢为，谁就最最正确"><a href="#谁能敢作敢为，谁就最最正确" class="headerlink" title="谁能敢作敢为，谁就最最正确"></a>谁能敢作敢为，谁就最最正确</h4><ul><li>权力只会给予敢于觊觎并夺取它的人。这里只有一个条件，仅仅一个条件：只要敢作敢为！</li><li>既然我反复自问：我有没有权利掌握权力？–那么，这就是说，我没有权利掌握权力。</li></ul><h4 id="总是希望生命有更大的意义"><a href="#总是希望生命有更大的意义" class="headerlink" title="总是希望生命有更大的意义"></a>总是希望生命有更大的意义</h4><ul><li>他一向认为，单单生存是不够的，他总是希望生命有更大的意义。也许只是由于他抱有希望，当时他才自认为是一个比别人享有更多权利的人吧！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;陀氏的《穷人的美德》，摘部分内容于此文中。&lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="https://www.wanglixia.top/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="陀思妥耶夫斯基" scheme="https://www.wanglixia.top/tags/%E9%99%80%E6%80%9D%E5%A6%A5%E8%80%B6%E5%A4%AB%E6%96%AF%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>学习jdk1.8-Lambda 表达式 与Collections</title>
    <link href="https://www.wanglixia.top/2018813214038%E5%AD%A6%E4%B9%A0jdk1-8.html"/>
    <id>https://www.wanglixia.top/2018813214038学习jdk1-8.html</id>
    <published>2018-08-13T13:45:14.000Z</published>
    <updated>2019-01-03T15:34:29.637Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;直到现在jdk1.8版本已经发布了有近5个年头了。今天做一个浅显的学习和记录，便于后面的查找。如果你也有兴趣，不妨一起交流交流，如有不对之处，还请指点指点…</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>&emsp;&emsp;看牛逼的代码，到处都是知识点。咱研究研究一些简单的，使用一些示例代码来进行操作。</p><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>老版本的Java中的排序方式,实现一组字符串按照字典反序排列，排序结果<code>[“peter”,”jany”,”brain”,”anna”,”alex”]</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>,<span class="string">"anna"</span>,<span class="string">"brain"</span>,<span class="string">"jany"</span>,<span class="string">"alex"</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Comparator 中 compare方法介绍：<br><img src="http://img.wanglixia.top//Comparator-compare-2018813224649.png" alt="Comparator-compare-2018813224649"><br>Collections 中 sort方法介绍：<br>该方法默认的排序是正序<br><img src="http://img.wanglixia.top//Collections_sort_1-2018813225316.png" alt="Collections_sort_1-2018813225316"><br><img src="http://img.wanglixia.top//Collections_sort_2-2018813225325.png" alt="Collections_sort_2-2018813225325"><br>String的compareTo方法：<br><code>public int compareTo(String anotherString)</code>如果参数字符串等于此字符串，则值为0 ; 如果这个字符串的字典比字符串参数小，则值小于0; 如果此字符串的字典大小超过字符串参数，则值大于0 。<br>Java8中的lambda表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names,(String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>更简单的方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names,(String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p><p>更更简单的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names,(a,b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p><p>一种不使用lambda表达式的方法，<code>reverseOrder()</code> 以反字典（字母顺序）排列阵列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, Comparator.reverseOrder());</span><br></pre></td></tr></table></figure></p><h3 id="Stream-接口"><a href="#Stream-接口" class="headerlink" title="Stream 接口"></a>Stream 接口</h3><p>&emsp;&emsp;Java8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p><ol><li>创建一个stream的方式,<code>Collection.stream()</code>创建了一个串行的stream；<code>Collection.parallelStream()</code>创建了一个并行的stream；：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">"ddd"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ccc"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa"</span>);</span><br><span class="line">Stream&lt;String&gt; stream = stringCollection.stream();</span><br><span class="line">Stream&lt;String&gt; stringStream = stringCollection.parallelStream();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;直到现在jdk1.8版本已经发布了有近5个年头了。今天做一个浅显的学习和记录，便于后面的查找。如果你也有兴趣，不妨一起交流交流，如有不对之处，还请指点指点…&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://www.wanglixia.top/tags/java/"/>
    
      <category term="jdk1.8" scheme="https://www.wanglixia.top/tags/jdk1-8/"/>
    
  </entry>
  
  <entry>
    <title>windows server 2012 的一些使用记录</title>
    <link href="https://www.wanglixia.top/windows-server-2012.html"/>
    <id>https://www.wanglixia.top/windows-server-2012.html</id>
    <published>2018-07-23T15:12:49.000Z</published>
    <updated>2018-12-28T15:49:31.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>windows server 2012 的一些操作记录。</p><ul><li><a href="#关闭IIS服务器">关闭IIS服务器</a></li></ul><a id="more"></a><h3 id="关闭IIS服务器"><a href="#关闭IIS服务器" class="headerlink" title="关闭IIS服务器"></a>关闭IIS服务器</h3><p>&emsp;&emsp;win+r输入services.msc打开服务，找到 <code>World Wide Web Publishing Service</code> 选择停止，用不到的话，选择禁用，然后确定；<br><img src="http://img.wanglixia.top//windows_server_stop_w3svc-201872323230.png" alt="windows_server_stop_w3svc-201872323230"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;windows server 2012 的一些操作记录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#关闭IIS服务器&quot;&gt;关闭IIS服务器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="server" scheme="https://www.wanglixia.top/categories/server/"/>
    
    
      <category term="windows" scheme="https://www.wanglixia.top/tags/windows/"/>
    
      <category term="server" scheme="https://www.wanglixia.top/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>Oracle中的常用函数</title>
    <link href="https://www.wanglixia.top/Oracle%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0.html"/>
    <id>https://www.wanglixia.top/Oracle中的常用函数.html</id>
    <published>2018-07-23T11:38:09.000Z</published>
    <updated>2019-02-03T06:41:07.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>整理一些oracle中最常用的方法，以作记录，便于使用时进行查找。（持续更新…）</p><h2 id="常用的一些函数"><a href="#常用的一些函数" class="headerlink" title="常用的一些函数"></a>常用的一些函数</h2><h3 id="nvl函数的使用-nvl-paramA-paramA-用于返回一个不为null的值；"><a href="#nvl函数的使用-nvl-paramA-paramA-用于返回一个不为null的值；" class="headerlink" title="nvl函数的使用:nvl(paramA,paramA)用于返回一个不为null的值；"></a>nvl函数的使用:nvl(paramA,paramA)用于返回一个不为null的值；</h3><pre><code>1. 有一个参数为null的情况，返回不为null的那个值；下例返回的就是 &lt;code&gt;1&lt;/code&gt;;<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> nvl(<span class="number">1</span>, <span class="literal">null</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>2. 两个参数都为null的情况，返回值为null；下例返回的结果就是&lt;code&gt;null&lt;/code&gt;;<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> nvl(<span class="literal">null</span>,<span class="literal">null</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>3. 两个参数都不为null的情况，返回第一个参数；下例返回的结果就是&lt;code&gt;1&lt;/code&gt;;<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> nvl(<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure></code></pre><p><strong>注意</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> nvl(<span class="string">''</span>,<span class="number">0.08</span>) <span class="keyword">from</span> dual;<span class="comment">--在oracle中返回的是.08</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">decode</span>(<span class="string">''</span>,<span class="literal">null</span>,<span class="number">0.08</span>) <span class="keyword">from</span> dual;<span class="comment">--返回0.08</span></span><br></pre></td></tr></table></figure><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;整理一些oracle中最常用的方法，以作记录，便于使用时进行查找。（持续更新…）&lt;/p&gt;
&lt;h2 id=&quot;常用的一些函数&quot;&gt;
      
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="oracle" scheme="https://www.wanglixia.top/tags/oracle/"/>
    
      <category term="数据库" scheme="https://www.wanglixia.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>winsows10环境下解决vmware中windows server服务器ping不通</title>
    <link href="https://www.wanglixia.top/2018-07-22-vmware-ping.html"/>
    <id>https://www.wanglixia.top/2018-07-22-vmware-ping.html</id>
    <published>2018-07-21T20:30:34.000Z</published>
    <updated>2018-12-28T15:49:31.779Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;使用vmware安装了windows server 2012，安装完毕之后，想从宿主机上远程到虚拟机中，发现本地网络和虚拟机网络不能ping通，试用了一个办法，可以ping通了，特意记录一下。<br><a id="more"></a></p><h3 id="环境参考"><a href="#环境参考" class="headerlink" title="环境参考"></a>环境参考</h3><ul><li>VMware® Workstation 14 Pro：14.1.1 build-7528167</li><li>宿主机：windows 10 </li><li>虚拟机：windows server 2012</li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>下面是宿主机的ip，即现在使用的是本地的主机：<br><img src="/images/blog/宿主机的ip.png" alt="宿主机的ip地址"></li><li>打开VMware-编辑-虚拟网络编辑器，选择右下角更改设置，设置NAT模式的子网地址跟主机一样，这里设置为192.168.2.0<br><img src="/images/blog/vmware的子网地址.png" alt="vmware的子网地址"></li><li>NAT设置 网关IP 也为192.168.2.***，DHCP的起始IP和结束IP的前三段也设置成跟主机一样的。然后就可以主机就可以ping通虚拟机了。</li></ul><h3 id="在远程的过程中还有一个问题"><a href="#在远程的过程中还有一个问题" class="headerlink" title="在远程的过程中还有一个问题"></a>在远程的过程中还有一个问题</h3><p>&emsp;&emsp;就是在远程的时候提示“出现身份验证错误，要求的函数不受支持…可能是由于CredSSP加密Oracle修正”，错误如下：<br><img src="/images/blog/CredSSP加密Oracle修正.png" alt="要求的函数不受支持"><br>处理这个问题是应该在<b style="color='red'">本地机器</b>进行修改，修改的方法是：</p><ul><li>win+r键打开运行框，然后输入<code>gpedit.msc</code>，回车，打开本地组策略编辑器；</li><li>在 “计算机配置-管理模板-系统-凭据分配”中 找到允许Oracle修正，之后双击，打开如下界面，点击已启用，保护级别选择易受攻击，保存即可。<br><img src="/images/blog/20180722050250.png" alt="修改允许Oracle修正"></li></ul><hr><h3 id="修正-2018-07-22-22-10"><a href="#修正-2018-07-22-22-10" class="headerlink" title="修正 2018-07-22 22:10"></a>修正 2018-07-22 22:10</h3><p>&emsp;&emsp;上述方法会导致虚拟机不能联网，以下能够<b>保证虚拟机上网，且主机能够远程虚拟机</b>的办法。本次不使用虚拟机进行网络设置，改为使用windows自带的网络设置。<br>该方法，主机修改为静态IP。首先，在主机命令行中执行<code>ipconfig/all</code>命令，查看本机IP，默认网关、以及DNS服务器地址。再将本机TCP/IPv4设置为以下属性：<br><img src="/images/blog/主机的静态ip设置.png" alt="主机的静态ip设置.png"><br>主机TCP/IPv4共享属性：<br><img src="/images/blog/主机的静态ip共享设置.png" alt="主机的静态ip共享设置.png"><br>即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;使用vmware安装了windows server 2012，安装完毕之后，想从宿主机上远程到虚拟机中，发现本地网络和虚拟机网络不能ping通，试用了一个办法，可以ping通了，特意记录一下。&lt;br&gt;
    
    </summary>
    
      <category term="vmware" scheme="https://www.wanglixia.top/categories/vmware/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="技术" scheme="https://www.wanglixia.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>记使用hexo搭建个人博客（二）</title>
    <link href="https://www.wanglixia.top/hexo-coding-github-2.html"/>
    <id>https://www.wanglixia.top/hexo-coding-github-2.html</id>
    <published>2018-07-21T02:57:36.000Z</published>
    <updated>2019-01-05T15:54:20.246Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;使用hexo+github/coding免费搭建个人博客，本文记录hexo博客的一些个性化配置。包括：</p><ul><li>修改主题、</li><li>头像、</li><li>评论、</li><li>搜索、</li><li>DaoVoice在线联系、</li><li>顶部加载条、</li><li>访问量统计、</li><li>第三方统计、<a id="more"></a></li></ul><h2 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h2><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>下载next主题，完成后，修改站点配置文件的 theme: landscape 为 theme: next，然后执行 hexo s 预览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h3 id="增加头像并加旋转特效"><a href="#增加头像并加旋转特效" class="headerlink" title="增加头像并加旋转特效"></a>增加头像并加旋转特效</h3><h3 id="增加统计字数、阅读时长"><a href="#增加统计字数、阅读时长" class="headerlink" title="增加统计字数、阅读时长"></a>增加统计字数、阅读时长</h3><p>&emsp;&emsp;在主题配置文件themes/next/_config.yml中找到以下内容：将wordcount、min2read修改为true</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  wordcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  min2read:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  totalcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>本地完成以上配置之后还需要增加<code>hexo-wordcount</code>插件，在命令行中执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><p>安装完毕之后，就可以预览了效果了。自定义样式，如<code>字数统计:<strong><em></em></strong></code>修改为<code>字数统计:字</code>,在themes/next/layout/_macro/post.swig中找到以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; wordcount(post.content) &#125;&#125;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; wordcount(post.content) &#125;&#125; 字</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p><code>阅读时长:<strong><em></em></strong></code>修改为<code>阅读时长:分钟</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; min2read(post.content) &#125;&#125; </span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; min2read(post.content) &#125;&#125; 分钟</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>即可。</p><h3 id="hexo增加七牛云图床及上传"><a href="#hexo增加七牛云图床及上传" class="headerlink" title="hexo增加七牛云图床及上传"></a>hexo增加七牛云图床及上传</h3><p>参考自： <a href="https://blog.csdn.net/qq_32454537/article/details/79482850" target="_blank" rel="noopener">使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境</a></p><p>工具：</p><ul><li>使用VSCode进行博客编写；</li><li><code>qiniu-upload-image</code>插件，需要进行配置；</li><li><code>vscode-Hexo</code>插件；</li><li>使用<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云,点击访问</a>作为图床，这个需要自己申请和认证哈，我的认证花了两天时间~~</li></ul><p><img src="http://img.wanglixia.top//七牛云新建存储空间-201872223148.png" alt="七牛云新建存储空间-201872223148"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;使用hexo+github/coding免费搭建个人博客，本文记录hexo博客的一些个性化配置。包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改主题、&lt;/li&gt;
&lt;li&gt;头像、&lt;/li&gt;
&lt;li&gt;评论、&lt;/li&gt;
&lt;li&gt;搜索、&lt;/li&gt;
&lt;li&gt;DaoVoice在线联系、&lt;/li&gt;
&lt;li&gt;顶部加载条、&lt;/li&gt;
&lt;li&gt;访问量统计、&lt;/li&gt;
&lt;li&gt;第三方统计、
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="hexo" scheme="https://www.wanglixia.top/tags/hexo/"/>
    
      <category term="github" scheme="https://www.wanglixia.top/tags/github/"/>
    
      <category term="coding" scheme="https://www.wanglixia.top/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>记使用hexo搭建个人博客（一）</title>
    <link href="https://www.wanglixia.top/hexo-coding-github-1.html"/>
    <id>https://www.wanglixia.top/hexo-coding-github-1.html</id>
    <published>2018-07-18T05:14:19.000Z</published>
    <updated>2019-01-13T03:24:41.021Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;作为一个码农来说，笔记是必不可少的，一是为了记录，二是为了分享。特意将使用hexo+github/coding免费搭建个人博客的过程也记录了一下，网上类似的文章太多了，有些配置的版本不一样，本文记录hexo环境的搭建及部署到coding/github上.</p><a id="more"></a><h3 id="Hexo是什么？"><a href="#Hexo是什么？" class="headerlink" title="Hexo是什么？"></a>Hexo是什么？</h3><p>&emsp;&emsp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>&emsp;&emsp;<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">详情可参考Hexo官方文档</a></p><h3 id="环境及版本"><a href="#环境及版本" class="headerlink" title="环境及版本"></a>环境及版本</h3><ul><li>系统: windows 10 </li><li>git: version 2.9.0.windows.1</li><li>node: v10.6.0</li><li>hexo: 3.7.1</li><li>hexo-cli: 1.1.0</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>到此步骤已经认为你已经安装了git和node.js。</p><ol><li>创建一个目录，比如在E盘根目录下，创建一个hexo文件夹，使用命令行进入此文件夹，(也可以进入此文件夹，右键Git Bash Here)输入：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>命令执行后的效果参考：</p><p><img src="http://img.wanglixia.top/hexo_install-20189921255.png" alt="hexo命令执行完毕效果"></p><ol start="2"><li>初始化项目，输入hexo init 项目名，如hexo init blog,将会自动生成blog目录，并自动生成一些目录及文件；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>   <img src="http://img.wanglixia.top/hexo_install_2-201915162144.png" alt="hexo_install_2-201915162144"><br>   <img src="http://img.wanglixia.top/hexo_install_3-20191516220.png" alt="hexo_install_3-20191516220"></p><ol start="3"><li>现在可以开始预览了,会出现提示在网址<a href="http://localhost:4000/预览" target="_blank" rel="noopener">http://localhost:4000/预览</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>&emsp;&emsp;在项目根目录，有个_config.yml,这个是站点配置文件，一些重要的配置都是在这里进行的。 详细的通用配置就参考官网吧，就不重复说了。下面主要记录一下一些个性化的功能。</p><ul><li>常用命令：<ul><li>hexo clean ：清除缓存文件 (db.json) 和已生成的静态文件 (public)。</li><li>hexo g ：生成静态文件。</li><li>hexo s ：本地发布预览。</li><li>hexo d ：远程发布。</li></ul></li></ul><h3 id="在coding上部署"><a href="#在coding上部署" class="headerlink" title="在coding上部署"></a>在coding上部署</h3><p>&emsp;&emsp;访问<a href="https://coding.net/" target="_blank" rel="noopener">coding官网</a>，注册账号，注册时的用户名，就是你访问自己博客地址的主体部分，注意点哦。</p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目:"></a>创建项目:</h4><p>   <img src="http://img.wanglixia.top/hexo_install_new_proj-201915162221.png" alt="hexo_install_new_proj-201915162221"></p><h4 id="查看静态pages服务，Coding-Pages-已经运行在-https-你的用户名-coding-me时，说明你配置成功了，我这边是解析自己的域名，略有点不一样。如下图所示："><a href="#查看静态pages服务，Coding-Pages-已经运行在-https-你的用户名-coding-me时，说明你配置成功了，我这边是解析自己的域名，略有点不一样。如下图所示：" class="headerlink" title="查看静态pages服务，Coding Pages 已经运行在 https://[你的用户名].coding.me时，说明你配置成功了，我这边是解析自己的域名，略有点不一样。如下图所示："></a>查看静态pages服务，Coding Pages 已经运行在 https://[你的用户名].coding.me时，说明你配置成功了，我这边是解析自己的域名，略有点不一样。如下图所示：</h4><p>   <img src="http://img.wanglixia.top/hexo_install_static_pages-201915162251.png" alt="hexo_install_static_pages-201915162251"></p><h4 id="接下来就要开始准备把项目发布到coding上面了，需要先获取SSHKey，然后修改站点配置文件为coding的项目对应的ssh地址；"><a href="#接下来就要开始准备把项目发布到coding上面了，需要先获取SSHKey，然后修改站点配置文件为coding的项目对应的ssh地址；" class="headerlink" title="接下来就要开始准备把项目发布到coding上面了，需要先获取SSHKey，然后修改站点配置文件为coding的项目对应的ssh地址；"></a>接下来就要开始准备把项目发布到coding上面了，需要先获取SSHKey，然后修改站点配置文件为coding的项目对应的ssh地址；</h4><p><em>设置Git的user name和email：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"你的git用户名，可以随便起一个"</span></span><br><span class="line">git config --global user.email <span class="string">"你的邮箱地址"</span></span><br></pre></td></tr></table></figure><p><em>执行以下命令，查看是否已经有了ssh密钥：cd ~/.ssh，输入第二条命令之后，连续3次enter</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"你的邮箱地址"</span></span><br></pre></td></tr></table></figure><p><em>在<code>C:\Users\你的电脑用户名.ssh</code> 目录下，会有两个文件id_rsa和id_rsa.pub，使用记事本打开id_rsa.pub，复制里面的值，然后浏览器打开你的coding到如下页面，将复制的内容粘贴到公钥内容的文本框里面，点击保存。如下图：</em><br><img src="http://img.wanglixia.top/hexo_install_ssh_key1-201915162310.png" alt="hexo_install_ssh_key1-201915162310"><br><em>测试公钥是否配置成功：<code>ssh -T <a href="mailto:git@git.coding.net" target="_blank" rel="noopener">git@git.coding.net</a></code>，输入之后，会提示你是否确认，输入yes，回车；提示你通过ssh协议认证。</em><br><em>修改你的站点配置文件，这个是在你的本地配置远程服务器地址，hexo项目根目录下的_config.yml，这种文件的格式非常严格，多一个空格就可能会报错。</em></p><p>码云和GitHub双线部署的配置，站点配置文件<code>_config.yml</code>下修改配置，修改为自己的仓库：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span></span><br><span class="line"><span class="attr">    coding:</span> <span class="string">git@git.coding.net:weyoung/weyoung.coding.me.git,master</span></span><br><span class="line"><span class="attr">    github:</span> <span class="string">git@github.com:nelucifer/nelucifer.github.io.git,master</span></span><br></pre></td></tr></table></figure></p><p><em>执行命令,就将你的博客部署到coding上了，如果要解析为自己的域名的话，可以百度、google查看步骤。</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><em>github 的部署和在coding上部署基本是一样的</em> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;作为一个码农来说，笔记是必不可少的，一是为了记录，二是为了分享。特意将使用hexo+github/coding免费搭建个人博客的过程也记录了一下，网上类似的文章太多了，有些配置的版本不一样，本文记录hexo环境的搭建及部署到coding/github上.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="hexo" scheme="https://www.wanglixia.top/tags/hexo/"/>
    
      <category term="github" scheme="https://www.wanglixia.top/tags/github/"/>
    
      <category term="coding" scheme="https://www.wanglixia.top/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>PowerDesigner导出PDM和rtf文件</title>
    <link href="https://www.wanglixia.top/PowerDesigner-export-PDM-rtf.html"/>
    <id>https://www.wanglixia.top/PowerDesigner-export-PDM-rtf.html</id>
    <published>2018-05-03T16:00:41.000Z</published>
    <updated>2019-01-05T10:06:09.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;power designer是能进行数据库设计的强大的软件，是一款开发人员常用的数据库建模工具。使用它可以分别从概念数据模型(Conceptual Data Model)和物理数据模型(Physical Data Model)两个层次对数据库进行设计。</p><ul><li>使用PowerDesigner导出rtf文件和PDM<a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2></li><li>PowerDesigner 16.5<h3 id="已有pdm导出rtf"><a href="#已有pdm导出rtf" class="headerlink" title="已有pdm导出rtf"></a>已有pdm导出rtf</h3>打开pdm后，右键点击后选择New-&gt;Report。<br><img src="http://img.wanglixia.top/pdm-新建report-20191517453.png" alt="pdm-新建report-20191517453"></li></ul><p>出现以下界面，里面的结构可以按你的要求自由组合。<br><img src="http://img.wanglixia.top/pdm-新建report-1-201915174539.png" alt="pdm-新建report-1-201915174539"><br><img src="http://img.wanglixia.top/pdm-新建report-2-201915175423.png" alt="pdm-新建report-2-201915175423"><br>一般将名称、代码、数据类型、注释<br><img src="http://img.wanglixia.top/pdm-新建report-3-201915175526.png" alt="pdm-新建report-3-201915175526"><br>选择导出即可。<br><img src="http://img.wanglixia.top/pdm-新建report-4-20191518343.png" alt="pdm-新建report-4-20191518343"><br><img src="http://img.wanglixia.top/pdm-新建report-5-2019151867.png" alt="pdm-新建report-5-2019151867"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;power designer是能进行数据库设计的强大的软件，是一款开发人员常用的数据库建模工具。使用它可以分别从概念数据模型(Conceptual Data Model)和物理数据模型(Physical Data Model)两个层次对数据库进行设计。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用PowerDesigner导出rtf文件和PDM
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="PowerDesigner" scheme="https://www.wanglixia.top/tags/PowerDesigner/"/>
    
  </entry>
  
  <entry>
    <title>微信授权登录(微信订阅号使用测试账号)</title>
    <link href="https://www.wanglixia.top/wechat-login.html"/>
    <id>https://www.wanglixia.top/wechat-login.html</id>
    <published>2017-09-17T07:44:41.000Z</published>
    <updated>2019-01-04T17:25:00.709Z</updated>
    
    <content type="html"><![CDATA[<p>微信作为现在最火的社交App，使用微信扫描二维码登录也更加方便和快捷，也不至于注册一大堆账号，想起来都烦。使用花生壳+微信测试账号+微信公众号+java做一个demo熟悉下微信开发。<br><a id="more"></a><br>demo地址：<a href="https://gitee.com/nelucifer/wxlogin-demo.git" target="_blank" rel="noopener">wxlogin-demo</a><br><em>Updated By Mr.wang 2019-1-4： 这个文章是在2017-09-17 在博客园写的，边写代码边写博客，记录的不够详细，还请包涵。微信把接口好像调整了，订阅号现在没有这个测试登录的权限了，但是整体实现应该是没有区别的。</em></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>花生壳：用来作为内网穿透，以便微信登录接口（需要公网中能够访问到的地址）回调，<a href="http://hsk.oray.com/download/" target="_blank" rel="noopener">花生壳下载链接</a></li><li>微信公众号：设置【授权回调页面域名】；</li><li>微信公众号开发测试账号：<a href="http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">点击访问申请地址</a><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2>在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；</li></ul><p><img src="http://img.wanglixia.top/网页授权获取用户基本信息_授权回调页面域名-20191423110.png" alt="网页授权获取用户基本信息_授权回调页面域名-20191423110"><br><img src="http://img.wanglixia.top/微信测试账号申请成功后-201914231111.png" alt="微信测试账号申请成功后-201914231111"></p><h3 id="开发demo所需要的jar包"><a href="#开发demo所需要的jar包" class="headerlink" title="开发demo所需要的jar包"></a>开发demo所需要的jar包</h3><p><img src="http://img.wanglixia.top/微信登录-所需要的jar包-201914231314.png" alt="微信登录-所需要的jar包-201914231314"></p><h3 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h3><h4 id="AuthUtil-java"><a href="#AuthUtil-java" class="headerlink" title="AuthUtil.java"></a>AuthUtil.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wanglixia;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.DefaultHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Created by Mr.wang on 2017/9/17 11:57.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APPID = <span class="string">"这块填appid"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APPSECRET = <span class="string">"这块是appsecret"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">doGetJson</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JSONObject jsonObject = <span class="keyword">null</span>;</span><br><span class="line">        DefaultHttpClient client = <span class="keyword">new</span> DefaultHttpClient();</span><br><span class="line">        HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">        HttpResponse httpResponse = client.execute(httpGet);</span><br><span class="line">        HttpEntity entity = httpResponse.getEntity();</span><br><span class="line">        <span class="keyword">if</span> (entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String result = EntityUtils.toString(entity, <span class="string">"UTF-8"</span>);</span><br><span class="line">            jsonObject = JSONObject.fromObject(result);</span><br><span class="line">        &#125;</span><br><span class="line">        httpGet.releaseConnection();</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CallBackServlet-java"><a href="#CallBackServlet-java" class="headerlink" title="CallBackServlet.java"></a>CallBackServlet.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wanglixia;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Created by Mr.wang on 2017/9/17 13:06.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/callBack"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBackServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String code = req.getParameter(<span class="string">"code"</span>);</span><br><span class="line">        String url = <span class="string">"https://api.weixin.qq.com/sns/oauth2/access_token?"</span> +</span><br><span class="line">                <span class="string">"appid="</span> + AuthUtil.APPID +</span><br><span class="line">                <span class="string">"&amp;secret="</span> + AuthUtil.APPSECRET +</span><br><span class="line">                <span class="string">"&amp;code="</span> + code +</span><br><span class="line">                <span class="string">"&amp;grant_type=authorization_code"</span>;</span><br><span class="line">        JSONObject jsonObject = AuthUtil.doGetJson(url);</span><br><span class="line">        System.out.println(jsonObject.toString());</span><br><span class="line">        String openid = jsonObject.getString(<span class="string">"openid"</span>);</span><br><span class="line">        String token = jsonObject.getString(<span class="string">"access_token"</span>);</span><br><span class="line"><span class="comment">//        String expires_in = jsonObject.getString("expires_in");</span></span><br><span class="line"><span class="comment">//        String refresh_token = jsonObject.getString("refresh_token");</span></span><br><span class="line"><span class="comment">//        String scope = jsonObject.getString("scope");</span></span><br><span class="line">        String infoUrl = <span class="string">"https://api.weixin.qq.com/sns/userinfo?"</span> +</span><br><span class="line">                <span class="string">"access_token="</span> + token +</span><br><span class="line">                <span class="string">"&amp;openid="</span> + openid +</span><br><span class="line">                <span class="string">"&amp;lang=zh_CN"</span>;</span><br><span class="line">        JSONObject userInfo = AuthUtil.doGetJson(infoUrl);</span><br><span class="line">        System.out.println(userInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、使用微信用户信息直接登录，无需注册和绑定</span></span><br><span class="line"><span class="comment">//        req.setAttribute("info", userInfo);</span></span><br><span class="line"><span class="comment">//        req.getRequestDispatcher("/index1.jsp").forward(req, resp);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WxLogin-java"><a href="#WxLogin-java" class="headerlink" title="WxLogin.java"></a>WxLogin.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wanglixia;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Created by Mr.wang on 2017/9/17 11:17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/wxLogin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WxLogin</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String backUrl = <span class="string">"http://这儿是你的回调地址，上图填的那个/callBack"</span>;</span><br><span class="line">        String url = <span class="string">"https://open.weixin.qq.com/connect/oauth2/authorize?"</span> +</span><br><span class="line">                <span class="string">"appid="</span> + AuthUtil.APPID +</span><br><span class="line">                <span class="string">"&amp;redirect_uri="</span> + URLEncoder.encode(backUrl) +</span><br><span class="line">                <span class="string">"&amp;response_type=code"</span> +</span><br><span class="line">                <span class="string">"&amp;scope=snsapi_userinfo"</span> +</span><br><span class="line">                <span class="string">"&amp;state=STATE#wechat_redirect"</span>;</span><br><span class="line">        resp.sendRedirect(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="index-jsp"><a href="#index-jsp" class="headerlink" title="index.jsp"></a>index.jsp</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Created</span> <span class="attr">by</span> <span class="attr">IntelliJ</span> <span class="attr">IDEA.</span></span></span><br><span class="line"><span class="tag">  <span class="attr">User:</span> <span class="attr">Mr.wang</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Date:</span> <span class="attr">2017</span>/<span class="attr">9</span>/<span class="attr">17</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Time:</span> <span class="attr">11:02</span></span></span><br><span class="line"><span class="tag">  <span class="attr">To</span> <span class="attr">change</span> <span class="attr">this</span> <span class="attr">template</span> <span class="attr">use</span> <span class="attr">File</span> | <span class="attr">Settings</span> | <span class="attr">File</span> <span class="attr">Templates.</span></span></span><br><span class="line"><span class="tag"><span class="attr">--</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"font-size: 40px;text-align: center;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/wxLogin"</span>&gt;</span>微信公众授权登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="index1-jsp"><a href="#index1-jsp" class="headerlink" title="index1.jsp"></a>index1.jsp</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Created</span> <span class="attr">by</span> <span class="attr">IntelliJ</span> <span class="attr">IDEA.</span></span></span><br><span class="line"><span class="tag">  <span class="attr">User:</span> <span class="attr">Mr.wang</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Date:</span> <span class="attr">2017</span>/<span class="attr">9</span>/<span class="attr">17</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Time:</span> <span class="attr">11:02</span></span></span><br><span class="line"><span class="tag">  <span class="attr">To</span> <span class="attr">change</span> <span class="attr">this</span> <span class="attr">template</span> <span class="attr">use</span> <span class="attr">File</span> | <span class="attr">Settings</span> | <span class="attr">File</span> <span class="attr">Templates.</span></span></span><br><span class="line"><span class="tag"><span class="attr">--</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>登录成功！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>$&#123;info&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;"</span> <span class="attr">src</span>=<span class="string">"$&#123;info.headimgurl&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="中间遇到的问题："><a href="#中间遇到的问题：" class="headerlink" title="中间遇到的问题："></a>中间遇到的问题：</h3><ul><li>接口回调地址设置错误，这个地址需要是公网中能够访问到的地址，因此需要用花生壳来进行内网映射；</li><li>因为没有微信公众服务号，因此，找了半天，突然想起有个测试账号。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>慕课网教程：<a href="http://www.imooc.com/learn/713" target="_blank" rel="noopener">http://www.imooc.com/learn/713</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信作为现在最火的社交App，使用微信扫描二维码登录也更加方便和快捷，也不至于注册一大堆账号，想起来都烦。使用花生壳+微信测试账号+微信公众号+java做一个demo熟悉下微信开发。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.wanglixia.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://www.wanglixia.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="微信" scheme="https://www.wanglixia.top/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
</feed>
