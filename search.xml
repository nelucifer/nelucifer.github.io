<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis系列——windows下redis设置及安装windows服务]]></title>
    <url>%2F2019%2F01%2F06%2Fredis-windows-install%2F</url>
    <content type="text"><![CDATA[前言Redis是一个开源（BSD许可），内存数据结构存储，用作数据库，缓存和消息代理。 它支持数据结构，如字符串，散列，列表，集合，带有范围查询的排序集，位图，超级日志，带有半径查询和流的地理空间索引。 Redis具有内置复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用性并使用Redis Cluster自动分区。本文简单记录一下windows下redis设置及安装成windows服务。 介绍 REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 百度百科：Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 官网介绍: Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.Google 翻译：Redis是一个开源（BSD许可），内存数据结构存储，用作数据库，缓存和消息代理。 它支持数据结构，如字符串，散列，列表，集合，带有范围查询的排序集，位图，超级日志，带有半径查询和流的地理空间索引。 Redis具有内置复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用性并使用Redis Cluster自动分区。 准备下载windows版的redis（解压版），下载地址：https://github.com/ServiceStack/redis-windows/tree/master/downloads下载Redis可视化工具 Redis Desktop Manager，下载地址：https://redisdesktop.com/download百度网盘：链接：https://pan.baidu.com/s/1vcRywB4JTA2xPCUvh0n1DA 提取码：y1vv安装步骤解压redis-64.3.0.503.zip；cmd命令进入该目录 文件 作用 redis-server 启动redis redis-cli redis命令行工具 redis-benchmark 基准测试工具 redis-check-aof AOF持久化文件检测工具和修复工具 redis-check-dump RDB持久化文件检测工具和修复工具 redis-sentinel 启动redis-sentinel 在解压后的文件夹里面，按住shift，然后鼠标右键点击空白区域，选择【在此处打开命令窗口】，快捷打开cmd窗口和当前目录。 启动：带配置文件启动redis:redis.windows.conf 这个文件是redis的配置文件，使用以下命令启动： 1redis-server.exe redis-windows.conf 不带配置文件启动：双击redis-server.exe；或者使用以下命令启动：1redis-server.exe 出现如下图时，启动成功。 登录redis启动redis服务后，需要登录redis来进行操作，这个时候需要按照上面步骤重新打开一个命令窗口，使用redis-cli命令进行登录，命令如下 -h 服务器/主机地址，本地就是127.0.0.1 -p 端口号，默认应该是6379 -a 密码 1redis-cli.exe -h 127.0.0.1 -a lucifer 登录成功后，如下图示： 重置密码打开redis.conf配置文件，我下载的版本配置文件名是redis-windows.conf，找到# requirepass foobared，去掉注释，井号代表注释，然后修改如下即可:1requirepass 你的密码 #我设置的是lucifer 安装成windows服务自己本地练习的时候呢，每一次都要打开目录，然后输入命令来启动服务，再打开另外一个窗口进行操作，确实是不方便，接下来将redis服务安装成windows服务。命令窗口执行以下命令： 1redis-server --service-install redis.windows.conf 常用命令 启动命令： 1redis-server --service-start 停止命令： 1redis-server --service-stop 卸载命令： 1redis-server --service-uninstall Redis可视化工具RedisDesktopManager使用黑窗口操作虽然看起来足够炫酷，但是终究还是不那么方便，因此，需要使用到RDM工具，这块比较简单了就。安装，一路next。填入连接名，随便填，你认识就行；服务器地址、端口号、密码，点测试连接；可以缓存到内容 结束]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>windows</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好用的前端响应式框架——Bootstrap]]></title>
    <url>%2F2019%2F01%2F05%2Fbootstrap-study-note%2F</url>
    <content type="text"><![CDATA[引言Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。 Bootstrap的优点： 移动设备优先。 响应式设计。基于bootstrap的网站和系统，能够自适应于台式机、平板电脑和手机。 容易上手。前置技能：HTML和CSS的基础知识即可。 浏览器支持比较好。IE、FireFox、Chrome、Opera、Safari等。 文档比较完善、内置组件比较多，容易定制。 开源。 准备Bootstrap提供多种使用方式：直接下载Bootstrap并引入；使用BootstrapCDN；包管理工具；npm、RubyGems、Composer、NuGet。这里主要说一下使用第一种方式（直接下载Bootstrap并引入），也是最常见的一种方式，也可以直接使用BootstrapCDN提供的免费CDN加速版本。 下载版本： 下载适用于生产环境的Bootstrap（不包含文档）； 下载Bootstrap源码（包含文档）； Sass 用于快速地在 Rails、Compass 或 只针对 Sass 的项目中引入。 下载链接：https://v3.bootcss.com/getting-started/#download-composer开始文件结构bootstrap/ css/ bootstrap.css bootstrap.min.css bootstrap-theme.css bootstrap-theme.min.css js/ bootstrap.js bootstrap.min.jsBootstrap使用在使用Bootstrap的html模板中进行使用。12345678910111213&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Bootstrap使用和效果预览&lt;/title&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel="stylesheet" href="/css/bootstrap.min.css"&gt; &lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt; &lt;link rel="stylesheet" href="/css/bootstrap-theme.min.css"&gt; &lt;!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) --&gt; &lt;script src="/js/jquery.js"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src="/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt; Bootstrap的相关概念Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。前面有说过bootstrap的一个优点，那就是移动设备优先：优先设计更小的宽度，即默认设计是移动设备的样式，再使用媒体查询来设置平板电脑、台式电脑以及大台式电脑。1234567891011/* 超小设备（手机，小于 768px） *//* Bootstrap 中默认情况下没有媒体查询 *//* 小型设备（平板电脑，768px 起） */@media (min-width: @screen-sm-min) &#123; ... &#125;/* 中型设备（台式电脑，992px 起） */@media (min-width: @screen-md-min) &#123; ... &#125;/* 大型设备（大台式电脑，1200px 起） */@media (min-width: @screen-lg-min) &#123; ... &#125; 具体设置及行为见下表： 超小设备手机（&lt;768px） 小型设备平板电脑（≥768px） 中型设备台式电脑（≥992px） 大型设备台式电脑（≥1200px） 网格行为 一直是水平的 以折叠开始，断点以上是水平的 以折叠开始，断点以上是水平的 以折叠开始，断点以上是水平的 最大容器宽度 None (auto) 750px 970px 1170px Class 前缀 .col-xs- .col-sm- .col-md- .col-lg- 列数量和 12 12 12 12 最大列宽 Auto 60px 78px 95px 间隙宽度 30px（一个列的每边分别 15px） 30px（一个列的每边分别 15px） 30px（一个列的每边分别 15px） 30px（一个列的每边分别 15px） 可嵌套 Yes Yes Yes Yes 偏移量 Yes Yes Yes Yes 列排序 Yes Yes Yes Yes Bootstrap怎么用？在一个div中的class中定义col--，第一个星号的值范围是[xs,sm,md,lg] ，第二个星号的值范围是1-12；因此设置的时候需要注意数值是否规范。12345678&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;!-- 在一个div中的class中定义col-*-*，第一个星号的值范围是[xs,sm,md,lg] ，第二个星号的值范围是1-12--&gt; &lt;div class="col-*-*"&gt;&lt;/div&gt; &lt;div class="col-*-*"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt;...&lt;/div&gt;&lt;/div&gt; Bootstrap布局组件 Bootstrap 字体图标 Bootstrap 下拉菜单 Bootstrap 按钮组 Bootstrap 按钮下拉菜单 Bootstrap 输入框组 Bootstrap 导航元素 Bootstrap 导航栏 Bootstrap 面包屑导航 Bootstrap 分页 Bootstrap 标签 Bootstrap 徽章 Bootstrap 超大屏幕 Bootstrap 页面标题 Bootstrap 缩略图 Bootstrap 警告 Bootstrap 进度条 Bootstrap 多媒体对象 Bootstrap 列表组 Bootstrap 面板 Bootstrap WellsBootstrap插件 Bootstrap 过渡效果 Bootstrap 模态框 Bootstrap 下拉菜单 Bootstrap 滚动监听 Bootstrap 标签页 Bootstrap 提示工具 Bootstrap 弹出框 Bootstrap 警告框 Bootstrap 按钮 Bootstrap 折叠 Bootstrap 轮播 Bootstrap 附加导航Bootstrap常用插件 表单验证插件 bootstrapValidator Messenger 弹框组件库结语文档上提供的BootstrapDialog模态框组件的实现比较繁琐，因此可以在网上找相关插件处理。文档 Bootstrap官网：http://www.bootcss.com/ Bootstrap官方文档：https://v3.bootcss.com/components/致谢在学习过程中，经常在菜鸟教程http://www.runoob.com/查阅资料，表示感谢。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>前端</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis常见错误记录]]></title>
    <url>%2F2019%2F01%2F03%2Fmybatis%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Mybatis使用过程中，常见的一些问题汇总记录。 1. Mybatis执行SQL，查出来的比使用PL/SQL等工具查出来的记录多。 问题描述：由于查询要使用到not in，因此 not in ()括号里面的东西自己使用了前端拼接传值，传值格式为’’,’’ 问题处理：在Mapper.xml中使用了#{}，这块涉及到#{}和${}的区别。替换成${} 就好了。 2. MyBatis mapper文件中的变量引用方式#{}与${}的差别默认情况下,使用#{}语法,MyBatis会产生PreparedStatement语句中，并且安全的设置PreparedStatement参数，这个过程中MyBatis会进行必要的安全检查和转义。示例1：执行SQL：1Select * from emp where name = #&#123;employeeName&#125; 参数：employeeName传入值为：Smith解析后执行的SQL：1Select * from emp where name = ? 执行SQL：1Select * from emp where name = $&#123;employeeName&#125; 参数：employeeName传入值为：Smith解析后执行的SQL：1Select * from emp where name = Smith 综上所述、${}方式会引发SQL注入的问题、同时也会影响SQL语句的预编译，所以从安全性和性能的角度出发，能使用#{}的情况下就不要使用${}${}的使用场景：有时候可能需要直接插入一个不做任何修改的字符串到SQL语句中。这时候应该使用${}语法。比如，动态SQL中的字段名，如：ORDER BY ${columnName}，not in ${items}注意：当使用${}参数作为字段名或表名时、需指定statementType为“STATEMENT”，如：123&lt;select id="queryMetaList" resultType="Map" statementType="STATEMENT"&gt; Select * from emp where name = $&#123;employeeName&#125; ORDER BY $&#123;columnName&#125;&lt;/select&gt; 3. ssm-web项目启动报错（一） Could not resolve type alias ‘map ‘. Cause: java.lang.ClassNotFoundException: Cannot find class: map 123&lt;select id="selectByCode" resultType="com.lucifer.pojo.BaseParams" parameterType="java.util.map"&gt; SELECT BP.ID,BP.NAME FROM BASE_PARAMS BP WHERE BP.DOMAIN=#&#123;domain&#125; AND BP.IS_CANCEL='N'&lt;/select&gt; 处理方式：把resultType改为resultMap，把parameterType改为parameterMap，重新发布并运行。 4. ssm-web项目启动报错（二） org.mybatis.spring.transaction.SpringManagedTransaction - JDBC Connection [**] will not be managed by Spring 处理方式：]]></content>
      <categories>
        <category>错误</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava]]></title>
    <url>%2F2019%2F01%2F02%2Frxjava%2F</url>
    <content type="text"><![CDATA[RxJava当被观察者(Observable)的生成速度大于观察者(Observer)的处理速度会出现 Backpressure 现象(只有在异步环境下会发生).会抛出 MissingBackpressureException 异常信息 Hot and Cold Observables Cold Observables：当被订阅后才开始发送事件的Observable(每个Subscriber都能接收到完整的事件) Hot Observables: 不管有没有被订阅,都会去发送事件的 Observable Hot Observable 是不支持背压的,Cold Observable 有一部分并不支持背压(比如interval，timer等操作符创建的Observable)rxJava2.0 已经解决了这个问题(?:Observable,有的支持背压,有的不支持) cold observable 相当于响应式拉(就是observer处理完了一个事件就从observable拉取下一个事件),hot observable通常不能很好的处理响应式拉模型,例如使用onBackpressureBuffer或者onBackpressureDrop 操作符,和其他操作符比如operators, throttling, buffers, or windows. observeOn这个操作符内部有一个缓冲区，默认长度是16.经常用到的Observable.create 就是 Cold Observable,而 just, range, timer 和 from 这些创建的同样是 Cold Observable.我们一般使用的都是Cold Observable,除非特殊需求,才会使用Hot Observable 背压操作符rxJava1.X 针对不支持背压提供的操作符有：sample(),throttleLast(),throttleFirst(),throttleWithTimeout(),debounce(),onBackpressurebuffer(),onBackpressureDrop() RxJava1.x vs RxJava2.x 2.x 发送事件时不能传 null,否则会抛出空指针异常 2.x 中 Observable 不再支持背压, 用 Flowable 来支持背压 线程调度方面 2.x 取消 Schedulers.immediate() RxJava2 BackpressureObservable拆分成了新的 Observable 和 Flowable,Observable 不具备处理背压能力,Flowable 解决了背压问题,Backpressure 只在异步情况下产生,RxJava2 的处理策略仅仅是对观察者接收事件的处理 1.ERROR产生背压问题会抛出 MissingBackpressureException 异常信息在异步调用时,RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据,缓存池的默认大小为128,即只能缓存128个事件.无论request()中传入的数字比128大或小,缓存池中在刚开始都会存入128个事件12Flowable.create(new FlowableOnSubscribe&lt;&gt;(),BackpressureStrategy.ERROR) .subscribe(new Subscriber()); BUFFER把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池，支持存很多很多的数据,比较消耗内存 DROP LATESTDROP 丢弃事件,LATEST使消费者能够接收到生产者产生的最后一个事件]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记使用hexo搭建个人博客-报错集锦]]></title>
    <url>%2F2018%2F12%2F29%2Fhexo-coding-github-%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;使用hexo+github/coding+next搭建个人博客过程中遇到的一些问题集中整理，包括： 报错一：TypeError: Cannot set property ‘lastIndex’ of undefined 报错二：Permission denied (publickey). 报错三：Error: ERROR: Repository not found. fatal: Could not read from remote repository. 报错一：TypeError: Cannot set property ‘lastIndex’ of undefined问题描述：使用hexo g 报错 TypeError: Cannot set property ‘lastIndex’ of undefined 问题处理：在hexo中的_config.yml 文件中的高亮功能设置错了，不是主题的_config.yml，其中的 auto_detect 应该设置为 false。12345highlight: enable: true line_number: true auto_detect: false tab_replace: 改过之后再执行就好了。 报错二： Permission denied (publickey).问题处理：第一步：创建SSH Key。windows下的目录C:\Users\用户名.ssh，看看有没有.ssh目录，，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：1ssh-keygen -t rsa -C "ne_lucifer@163.com" 你需要把邮件地址换成你自己的邮件地址，然后点击回车，使用默认值即可。第二步：登录Github（登录后路径https://github.com/settings/keys）或者Coding(登录后路径)，按如下步骤操作，用记事本打开id_rsa.pub，全选，把里面的内容粘贴到公钥内容里，title随便起一个 报错三： Error: ERROR: Repository not found. fatal: Could not read from remote repository.问题描述：使用hexo d部署项目到pages服务时报错1234567891011121314Please make sure you have the correct access rightsand the repository exists.FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: ERROR: Repository not found.fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. at ChildProcess.&lt;anonymous&gt; (F:\WorkSpaces\hexo\blog\node_modules\hexo-util\lib\spawn.js:37:17) at ChildProcess.emit (events.js:182:13) at ChildProcess.cp.emit (F:\WorkSpaces\hexo\blog\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:962:16) at Socket.stream.socket.on (internal/child_process.js:381:11) at Socket.emit (events.js:182:13) at Pipe._handle.close (net.js:606:12) 查看远端有没有这个分支；使用ssh -T git@git.coding.net命令，会出现下面信息，输入yes然后回车即可部署。123The authenticity of host &apos;git.coding.net (118.25.166.124)&apos; can&apos;t be established.RSA key fingerprint is SHA256:这块是一串编码.Are you sure you want to continue connecting (yes/no)?]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>coding</tag>
        <tag>next</tag>
        <tag>gitalk</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记使用hexo搭建个人博客（三）]]></title>
    <url>%2F2018%2F12%2F29%2Fhexo-coding-github-3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;使用hexo+next+github/coding+gitalk添加博客评论系统,以及hexo+next+码云+issue，这里使用的是next主题，如有问题，可以在博客下方评论。本文内容如下： 使用gitalk为博客添加评论功能、 vscode 使用七牛云做图床、 Hexo Next主题SEO优化、 next主题添加gitalk 准备在使用gitalk作为评论系统之前，需要在github上注册新的应用； 注册GitHub应用链接。按如下描述填写:填写完成后，点击绿色按钮，跳转到一下页面，可以看到Client ID和Client Secret，后面会用到。在项目目录下执行如下命令npm install gitalk –save 安装gitalk； 修改的内容新建gitalk.swig；路径themes/next/layout/_third-party/comments/gitalk.swig，内容如下：12345678910111213141516&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], id: location.pathname, distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125; 修改comments.swig路径themes/next/layout/_partials/comments.swig，在最后一个div里面加上如下内容：12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; 修改index.swig路径themes/next/layout/_third-party/comments/index.swig，在最后一行加上如下内容：1&#123;% include &apos;gitalk.swig&apos; %&#125; 新建gitalk.styl路径themes/next/source/css/_common/components/third-party/gitalk.styl，内容如下：1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 修改third-party.styl路径themes/next/source/css/_common/components/third-party/gitalk.styl，在最后一行加上如下内容：1@import &quot;gitalk&quot;; 修改文件_config.yml路径themes/next/_config.yml，注意是主题的配置文件，增加内容如下：12345678910gitalk: enable: true githubID: nelucifer # 例：nelucifer repo: nelucifer.github.io # 存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名） 例：nelucifer.github.io ClientID: 这块填注册Github应用成功之后的ClientID ClientSecret: 注册Github应用成功之后的ClientSecret #owner: 'Github 用户名', adminUser: ['nelucifer'] #指定可初始化评论账户，Github仓库的管理员，可以有多个 distractionFreeMode: true #id: 'window.location.pathname' #页面的唯一标识，gitalk根据这个标识自动创建的issue的标签,此处使用页面的相对路径作为标识 参考文章&emsp;&emsp;在使用gitalk作为评论系统的时候，参考了以下文章，特此添加链接，表示感谢： hexo 博客next主题集成gitment或者gitalk评论系统 hexo next主题深度优化(五)，评论系统换成gittalk vscode + 七牛云现在使用七牛云做图床需要已经备案的域名，测试域名不能用啦。 准备 下载vscode，这儿是下载链接 七牛云，传送门安装七牛云插件 安装插件：qiniu-upload-image 文件&gt;首选项&gt;设置，在右侧setting.json填写自己的配置覆盖默认配置。配置文件如下，使用的配置是七牛云里面的【密钥管理】：123456789101112131415161718192021&#123; // 一个有效的七牛 AccessKey 签名授权。 &quot;qiniu.access_key&quot;: &quot;密钥管理里面的AK&quot;, // 七牛图片上传空间。 &quot;qiniu.bucket&quot;: &quot;weyoung-pub&quot;, // 七牛图床域名。 &quot;qiniu.domain&quot;: &quot;自己配置的图床域名，使用二级域名就行&quot;, // 七牛图片上传工具开关 &quot;qiniu.enable&quot;: true, // 七牛图片上传路径，参数化命名。 &quot;qiniu.remotePath&quot;: &quot;$&#123;fileName&#125;-$&#123;dateTime&#125;&quot;, // 一个有效的七牛 SecretKey 签名授权。 &quot;qiniu.secret_key&quot;: &quot;密钥管理里面的SK&quot;, &quot;files.autoSave&quot;: &quot;afterDelay&quot;, &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\Windows\\System32\\cmd.exe&quot;,&#125; 使用快捷键 粘贴图片路径上传：SHIFT + P直接选择图片上传：SHIFT + O 安装插件Ctrl+P 输入命令：1ext install qiniu-upload-image 完成Hexo Next 主题SEO优化SEO ？汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。 针对百度搜索引擎的优化1. 添加百度sitemap，生成sitemap文件安装两个插件12npm install hexo-generator-sitemap --save-devnpm install hexo-generator-baidu-sitemap --save-dev 上面的是传统的sitemap，下面的是百度专有的sitemap。测试是否安装成功。使用命令hexo s本地预览。本地预览：[http://localhost:4000/sitemap.xml]http://localhost:4000/sitemap.xml 和 [http://localhost:4000/baidusitemap.xml]http://localhost:4000/baidusitemap.xml 显示sitemap文件内容。 2. 注册百度搜索资源工具地址：https://ziyuan.baidu.com/添加网站之后，需要验证，验证方式有文件验证、HTML标签验证、CNAME验证。我使用文件验证进行验证。下载验证文件，放到博客项目的source文件夹下，使用hexo g -d，部署到自己的网站上，如果不清楚部署的可以看前两篇文章；部署之后，在站长工具页面点击验证]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>coding</tag>
        <tag>next</tag>
        <tag>gitalk</tag>
        <tag>gitee</tag>
        <tag>码云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm常用命令]]></title>
    <url>%2F2018%2F12%2F28%2Fnpm-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 使用npm的时候，有一些命令及配置常用到，记录。 npm修改源&emsp;&emsp;使用npm在npm install时，速度特别慢，因此修改npm的数据源1npm config set registry https://registry.npm.taobao.org 修改后，即可进行下载啦，速度快了好多~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之陀氏-穷人的美德]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%9C%8B%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%99%80%E6%B0%8F-%E7%A9%B7%E4%BA%BA%E7%9A%84%E7%BE%8E%E5%BE%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;陀氏的《穷人的美德》，摘部分内容于此文中。 目录穷人的美德就是会赚钱 穷人最重要的美德就是会赚钱，道德就是一个人不该成为其他人的累赘 。 要爱别人，首先爱自己，因为世界上的一切都是以个人利益为基础的。 有几个人的表现特别突出，自然招来一些流言蜚语。因为没有流言蜚语，世界就无法存在，千百万人就会像苍蝇一样，因为寂寞无聊而死去。 用千万件好事去抵一桩小罪 命定的事总是会实现的，有价值的人将占有他应有的位置，而无价值的人将永远躲进小胡同，躲进他肮脏的小胡同，他喜爱而且正适合于他的小胡同，并且就在那污秽和臭气中，心甘情愿而且愉快地结束他的生命。 我们每个人都应该对世上一切人和一切事物负责，这一点是毫无疑义的，这不但是因为大家都参与了整个世界的罪恶，也是因为个人本来就应该为世上的一切人和一切事物负责。 在这种放荡生活里至少有一种固定不变的东西，它甚至是以天性为基础，而不是为幻想所左右的，它犹如血液中永不熄灭的炭火，永远燃烧着，还要燃烧很久很久，随着年龄的增长，或许也不能让它很快熄灭。 一时糊涂与意志衰退天才人物与犯罪的权利 总而言之，我得出结论，所有这些人，不仅是那些伟大的，就连那些稍微越出常轨的人，也就是说，就连那些稍微能提出点儿什么新见解的人，就其天性来说，必须是罪人–当然，只是在一定程度上，不然，他们就难以越出常轨；而让他们循规蹈矩，不越雷池一步，他们当然不会同意，这又是由于他们的天性，而照我看，他们甚至有责任不同意。 按照自然规律，人一般可以分作两类：一类是低级的（平凡的），也可以这么说吧。仅仅是一种繁殖同类的材料；另一类是名副其实的人，也就是有天赋或天才，能在自己的社会上发表新见解的人。……第一类人永远是当代的主人，第二类人却是未来的主人。第一类人保全世界，增加人的数量；第二类人则推动世界向前发展，引导它达到自己的目的。无论是这一类人，还是那一类人，都有完全同等的生存权利。 我杀死的只是原则 一般说，有新思想的人，即使只是稍微能发表某种新见解的人，通常是生得很少的，甚至少得出奇。明确的只有一点：必须有某种自然法则来正确无误地确定人的出生规律，正确无误地确定分类和区分他们的规律。 对于一个知识全面、思想深刻的人，痛苦是必然的，既有精神上的痛苦，也有肉体上的痛苦，我觉得，真正的伟人应该察觉到人世间极大地忧虑。 ……“单就这一点来说，我就是一只虱子，因为，第一，现在我认为我是只虱子；第二，因为整整一个月来，我一直在打搅仁慈的上帝，请他作证，说是，我这么做不是为了自己肉体上的享受和满足自己的淫欲，而是有一个让人感到高兴的崇高目的–哈–哈！… …” 谁能敢作敢为，谁就最最正确 权力只会给予敢于觊觎并夺取它的人。这里只有一个条件，仅仅一个条件：只要敢作敢为！ 既然我反复自问：我有没有权利掌握权力？–那么，这就是说，我没有权利掌握权力。 总是希望生命有更大的意义 他一向认为，单单生存是不够的，他总是希望生命有更大的意义。也许只是由于他抱有希望，当时他才自认为是一个比别人享有更多权利的人吧！]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>陀思妥耶夫斯基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习jdk1.8-Lambda 表达式 与Collections]]></title>
    <url>%2F2018%2F08%2F13%2F2018813214038%E5%AD%A6%E4%B9%A0jdk1-8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;直到现在jdk1.8版本已经发布了有近5个年头了。今天做一个浅显的学习和记录，便于后面的查找。如果你也有兴趣，不妨一起交流交流，如有不对之处，还请指点指点… 写在前面&emsp;&emsp;看牛逼的代码，到处都是知识点。咱研究研究一些简单的，使用一些示例代码来进行操作。 Lambda 表达式老版本的Java中的排序方式,实现一组字符串按照字典反序排列，排序结果[“peter”,”jany”,”brain”,”anna”,”alex”]：12345678List&lt;String&gt; names = Arrays.asList("peter","anna","brain","jany","alex");Collections.sort(names, new Comparator&lt;String&gt;()&#123; @Override public int compare(String a, String b)&#123; return b.compareTo(a); &#125;&#125;) Comparator 中 compare方法介绍：Collections 中 sort方法介绍：该方法默认的排序是正序String的compareTo方法：public int compareTo(String anotherString)如果参数字符串等于此字符串，则值为0 ; 如果这个字符串的字典比字符串参数小，则值小于0; 如果此字符串的字典大小超过字符串参数，则值大于0 。Java8中的lambda表达式：123Collections.sort(names,(String a, String b) -&gt; &#123; return b.compareTo(a);&#125;) 更简单的方式:1Collections.sort(names,(String a, String b) -&gt; b.compareTo(a)); 更更简单的方式：1Collections.sort(names,(a,b) -&gt; b.compareTo(a)); 一种不使用lambda表达式的方法，reverseOrder() 以反字典（字母顺序）排列阵列：1Collections.sort(names, Comparator.reverseOrder()); Stream 接口&emsp;&emsp;Java8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。 创建一个stream的方式,Collection.stream()创建了一个串行的stream；Collection.parallelStream()创建了一个并行的stream；：1234567List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();stringCollection.add("ddd");stringCollection.add("ccc");stringCollection.add("bbb");stringCollection.add("aaa");Stream&lt;String&gt; stream = stringCollection.stream();Stream&lt;String&gt; stringStream = stringCollection.parallelStream();]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk1.8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows server 2012 的一些使用记录]]></title>
    <url>%2F2018%2F07%2F23%2Fwindows-server-2012%2F</url>
    <content type="text"><![CDATA[写在前面windows server 2012 的一些操作记录。 关闭IIS服务器 关闭IIS服务器&emsp;&emsp;win+r输入services.msc打开服务，找到 World Wide Web Publishing Service 选择停止，用不到的话，选择禁用，然后确定；]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle中的常用函数]]></title>
    <url>%2F2018%2F07%2F23%2FOracle%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面整理一些oracle中最常用的方法，以作记录，便于使用时进行查找。（持续更新…） 常用的一些函数nvl函数的使用:nvl(paramA,paramA)用于返回一个不为null的值；1. 有一个参数为null的情况，返回不为null的那个值；下例返回的就是 &lt;code&gt;1&lt;/code&gt;; 1select nvl(1, null) from dual; 2. 两个参数都为null的情况，返回值为null；下例返回的结果就是&lt;code&gt;null&lt;/code&gt;; 1select nvl(null,null) from dual; 3. 两个参数都不为null的情况，返回第一个参数；下例返回的结果就是&lt;code&gt;1&lt;/code&gt;; 1select nvl(1,2) from dual; ###]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[winsows10环境下解决vmware中windows server服务器ping不通]]></title>
    <url>%2F2018%2F07%2F22%2F2018-07-22-vmware-ping%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;使用vmware安装了windows server 2012，安装完毕之后，想从宿主机上远程到虚拟机中，发现本地网络和虚拟机网络不能ping通，试用了一个办法，可以ping通了，特意记录一下。 环境参考 VMware® Workstation 14 Pro：14.1.1 build-7528167 宿主机：windows 10 虚拟机：windows server 2012 解决办法 下面是宿主机的ip，即现在使用的是本地的主机： 打开VMware-编辑-虚拟网络编辑器，选择右下角更改设置，设置NAT模式的子网地址跟主机一样，这里设置为192.168.2.0 NAT设置 网关IP 也为192.168.2.***，DHCP的起始IP和结束IP的前三段也设置成跟主机一样的。然后就可以主机就可以ping通虚拟机了。 在远程的过程中还有一个问题&emsp;&emsp;就是在远程的时候提示“出现身份验证错误，要求的函数不受支持…可能是由于CredSSP加密Oracle修正”，错误如下：处理这个问题是应该在本地机器进行修改，修改的方法是： win+r键打开运行框，然后输入gpedit.msc，回车，打开本地组策略编辑器； 在 “计算机配置-管理模板-系统-凭据分配”中 找到允许Oracle修正，之后双击，打开如下界面，点击已启用，保护级别选择易受攻击，保存即可。 修正 2018-07-22 22:10&emsp;&emsp;上述方法会导致虚拟机不能联网，以下能够保证虚拟机上网，且主机能够远程虚拟机的办法。本次不使用虚拟机进行网络设置，改为使用windows自带的网络设置。该方法，主机修改为静态IP。首先，在主机命令行中执行ipconfig/all命令，查看本机IP，默认网关、以及DNS服务器地址。再将本机TCP/IPv4设置为以下属性：主机TCP/IPv4共享属性：即可。]]></content>
      <categories>
        <category>vmware</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记使用hexo搭建个人博客（二）]]></title>
    <url>%2F2018%2F07%2F21%2Fhexo-coding-github-2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;使用hexo+github/coding免费搭建个人博客，本文记录hexo博客的一些个性化配置。包括： 修改主题、 头像、 评论、 搜索、 DaoVoice在线联系、 顶部加载条、 访问量统计、 第三方统计、 个性化配置修改主题下载next主题，完成后，修改站点配置文件的 theme: landscape 为 theme: next，然后执行 hexo s 预览 1git clone https://github.com/iissnan/hexo-theme-next themes/next 增加头像并加旋转特效增加统计字数、阅读时长&emsp;&emsp;在主题配置文件themes/next/_config.yml中找到以下内容：将wordcount、min2read修改为true 123456post_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 本地完成以上配置之后还需要增加hexo-wordcount插件，在命令行中执行以下命令： 1npm i --save hexo-wordcount 安装完毕之后，就可以预览了效果了。自定义样式，如字数统计:修改为字数统计:字,在themes/next/layout/_macro/post.swig中找到以下内容 123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt; 修改为123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; 阅读时长:修改为阅读时长:分钟 123&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt; &#123;&#123; min2read(post.content) &#125;&#125; &lt;/span&gt; 修改为123&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 即可。 hexo增加七牛云图床及上传参考自： 使用VSCode+七牛云图床插件+自定义快捷键配置Hexo博文编写环境 工具： 使用VSCode进行博客编写； qiniu-upload-image插件，需要进行配置； vscode-Hexo插件； 使用七牛云,点击访问作为图床，这个需要自己申请和认证哈，我的认证花了两天时间~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记使用hexo搭建个人博客（一）]]></title>
    <url>%2F2018%2F07%2F18%2Fhexo-coding-github-1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;作为一个码农来说，笔记是必不可少的，一是为了记录，二是为了分享。特意将使用hexo+github/coding免费搭建个人博客的过程也记录了一下，网上类似的文章太多了，有些配置的版本不一样，本文记录hexo环境的搭建及部署到coding/github上. Hexo是什么？&emsp;&emsp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&emsp;&emsp;详情可参考Hexo官方文档 环境及版本 系统: windows 10 git: version 2.9.0.windows.1 node: v10.6.0 hexo: 3.7.1 hexo-cli: 1.1.0 安装到此步骤已经认为你已经安装了git和node.js。 创建一个目录，比如在E盘根目录下，创建一个hexo文件夹，使用命令行进入此文件夹，(也可以进入此文件夹，右键Git Bash Here)输入： 12npm install -g hexo-clinpm install hexo --save 命令执行后的效果参考： 初始化项目，输入hexo init 项目名，如hexo init blog,将会自动生成blog目录，并自动生成一些目录及文件； 123hexo init blogcd blognpm install 现在可以开始预览了,会出现提示在网址http://localhost:4000/预览 12hexo ghexo s 常用命令&emsp;&emsp;在项目根目录，有个_config.yml,这个是站点配置文件，一些重要的配置都是在这里进行的。 详细的通用配置就参考官网吧，就不重复说了。下面主要记录一下一些个性化的功能。 常用命令： hexo clean ：清除缓存文件 (db.json) 和已生成的静态文件 (public)。 hexo g ：生成静态文件。 hexo s ：本地发布预览。 hexo d ：远程发布。 在coding上部署&emsp;&emsp;访问coding官网，注册账号，注册时的用户名，就是你访问自己博客地址的主体部分，注意点哦。 创建项目: 查看静态pages服务，Coding Pages 已经运行在 https://[你的用户名].coding.me时，说明你配置成功了，我这边是解析自己的域名，略有点不一样。如下图所示： 接下来就要开始准备把项目发布到coding上面了，需要先获取SSHKey，然后修改站点配置文件为coding的项目对应的ssh地址；设置Git的user name和email： 12git config --global user.name "你的git用户名，可以随便起一个"git config --global user.email "你的邮箱地址" 执行以下命令，查看是否已经有了ssh密钥：cd ~/.ssh，输入第二条命令之后，连续3次enter 12cd ~/.sshssh-keygen -t rsa -C "你的邮箱地址" 在C:\Users\你的电脑用户名.ssh 目录下，会有两个文件id_rsa和id_rsa.pub，使用记事本打开id_rsa.pub，复制里面的值，然后浏览器打开你的coding到如下页面，将复制的内容粘贴到公钥内容的文本框里面，点击保存。如下图：测试公钥是否配置成功：ssh -T git@git.coding.net，输入之后，会提示你是否确认，输入yes，回车；提示你通过ssh协议认证。修改你的站点配置文件，这个是在你的本地配置远程服务器地址，hexo项目根目录下的_config.yml，这种文件的格式非常严格，多一个空格就可能会报错。 12345deploy: type: git repository: git@git.coding.net:[你的用户名]/[你的用户名].coding.me.git# repository: git@github.com:[你的用户名]/[你的用户名].github.io.git branch: master 执行命令,就将你的博客部署到coding上了，如果要解析为自己的域名的话，可以百度、google查看步骤。 123hexo cleanhexo ghexo d github 的部署和在coding上部署基本是一样的]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerDesigner导出PDM和rtf文件]]></title>
    <url>%2F2018%2F05%2F04%2FPowerDesigner-export-PDM-rtf%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;power designer是能进行数据库设计的强大的软件，是一款开发人员常用的数据库建模工具。使用它可以分别从概念数据模型(Conceptual Data Model)和物理数据模型(Physical Data Model)两个层次对数据库进行设计。 使用PowerDesigner导出rtf文件和PDM 准备 PowerDesigner 16.5已有pdm导出rtf打开pdm后，右键点击后选择New-&gt;Report。 出现以下界面，里面的结构可以按你的要求自由组合。一般将名称、代码、数据类型、注释选择导出即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>PowerDesigner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信授权登录(微信订阅号使用测试账号)]]></title>
    <url>%2F2017%2F09%2F17%2Fwechat-login%2F</url>
    <content type="text"><![CDATA[微信作为现在最火的社交App，使用微信扫描二维码登录也更加方便和快捷，也不至于注册一大堆账号，想起来都烦。使用花生壳+微信测试账号+微信公众号+java做一个demo熟悉下微信开发。demo地址：wxlogin-demo Updated By Mr.wang 2019-1-4： 这个文章是在2017-09-17 在博客园写的，边写代码边写博客，记录的不够详细，还请包涵。微信把接口好像调整了，订阅号现在没有这个测试登录的权限了，但是整体实现应该是没有区别的。 准备 花生壳：用来作为内网穿透，以便微信登录接口（需要公网中能够访问到的地址）回调，花生壳下载链接 微信公众号：设置【授权回调页面域名】； 微信公众号开发测试账号：点击访问申请地址注意事项在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头； 开发demo所需要的jar包 直接上代码AuthUtil.java1234567891011121314151617181920212223242526272829303132333435package com.wanglixia;import net.sf.json.JSONObject;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.util.EntityUtils;import java.io.IOException;/** * 功能描述: * &lt;p&gt; * Created by Mr.wang on 2017/9/17 11:57. */public class AuthUtil &#123; public static final String APPID = "这块填appid"; public static final String APPSECRET = "这块是appsecret"; public static JSONObject doGetJson(String url) throws IOException &#123; JSONObject jsonObject = null; DefaultHttpClient client = new DefaultHttpClient(); HttpGet httpGet = new HttpGet(url); HttpResponse httpResponse = client.execute(httpGet); HttpEntity entity = httpResponse.getEntity(); if (entity != null) &#123; String result = EntityUtils.toString(entity, "UTF-8"); jsonObject = JSONObject.fromObject(result); &#125; httpGet.releaseConnection(); return jsonObject; &#125;&#125; CallBackServlet.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.wanglixia;import net.sf.json.JSONObject;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 功能描述: * &lt;p&gt; * Created by Mr.wang on 2017/9/17 13:06. */@WebServlet("/callBack")public class CallBackServlet extends HttpServlet &#123; protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String code = req.getParameter("code"); String url = "https://api.weixin.qq.com/sns/oauth2/access_token?" + "appid=" + AuthUtil.APPID + "&amp;secret=" + AuthUtil.APPSECRET + "&amp;code=" + code + "&amp;grant_type=authorization_code"; JSONObject jsonObject = AuthUtil.doGetJson(url); System.out.println(jsonObject.toString()); String openid = jsonObject.getString("openid"); String token = jsonObject.getString("access_token");// String expires_in = jsonObject.getString("expires_in");// String refresh_token = jsonObject.getString("refresh_token");// String scope = jsonObject.getString("scope"); String infoUrl = "https://api.weixin.qq.com/sns/userinfo?" + "access_token=" + token + "&amp;openid=" + openid + "&amp;lang=zh_CN"; JSONObject userInfo = AuthUtil.doGetJson(infoUrl); System.out.println(userInfo); //1、使用微信用户信息直接登录，无需注册和绑定// req.setAttribute("info", userInfo);// req.getRequestDispatcher("/index1.jsp").forward(req, resp); &#125;&#125; WxLogin.java12345678910111213141516171819202122232425262728package com.wanglixia;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.net.URLEncoder;/** * 功能描述: * &lt;p&gt; * Created by Mr.wang on 2017/9/17 11:17. */@WebServlet("/wxLogin")public class WxLogin extends HttpServlet &#123; protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String backUrl = "http://这儿是你的回调地址，上图填的那个/callBack"; String url = "https://open.weixin.qq.com/connect/oauth2/authorize?" + "appid=" + AuthUtil.APPID + "&amp;redirect_uri=" + URLEncoder.encode(backUrl) + "&amp;response_type=code" + "&amp;scope=snsapi_userinfo" + "&amp;state=STATE#wechat_redirect"; resp.sendRedirect(url); &#125;&#125; index.jsp1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: Mr.wang Date: 2017/9/17 Time: 11:02 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt; &lt;title&gt;$Title$&lt;/title&gt;&lt;/head&gt;&lt;body style="font-size: 40px;text-align: center;"&gt;&lt;a href="/wxLogin"&gt;微信公众授权登录&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; index1.jsp12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: Mr.wang Date: 2017/9/17 Time: 11:02 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt; &lt;title&gt;$Title$&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;登录成功！&lt;/div&gt;&lt;div&gt;$&#123;info&#125;&lt;/div&gt;&lt;div&gt;&lt;img style="width: 100px;height: 100px;" src="$&#123;info.headimgurl&#125;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 中间遇到的问题： 接口回调地址设置错误，这个地址需要是公网中能够访问到的地址，因此需要用花生壳来进行内网映射； 因为没有微信公众服务号，因此，找了半天，突然想起有个测试账号。 参考慕课网教程：http://www.imooc.com/learn/713]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端模板引擎Freemarker的使用（一）]]></title>
    <url>%2F2017%2F08%2F03%2Ffreemarker-1%2F</url>
    <content type="text"><![CDATA[介绍：FreeMarker 是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。模板编写为FreeMarker Template Language (FTL)。它是简单的，专用的语言， 不是 像PHP那样成熟的编程语言。 那就意味着要准备数据在真实编程语言中来显示，比如数据库查询和业务运算， 之后模板显示已经准备好的数据。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。 记录Freemarker在项目中的配置与使用 准备 框架：Spring+SpringMvc+Mybatis Freemarker：官网介绍配置Maven中需要引入的依赖1234567&lt;!-- freemarker的版本号 --&gt;&lt;freemarker.version&gt;2.3.20&lt;/freemarker.version&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;$&#123;freemarker.version&#125;&lt;/version&gt;&lt;/dependency&gt; 视图解析器，一般在spring-mvc.xml中配置12345678910&lt;!-- ViewResolver For FreeMarker --&gt;&lt;bean id="freemarkerResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; &lt;property name="viewClass"&gt; &lt;value&gt;org.springframework.web.servlet.view.freemarker.FreeMarkerView&lt;/value&gt; &lt;/property&gt; &lt;property name="suffix" value=".ftl"/&gt; &lt;property name="contentType" value="text/html;charset=utf-8"/&gt; &lt;property name="requestContextAttribute" value="request"/&gt; &lt;property name="order" value="0"/&gt;&lt;/bean&gt; 123456789101112131415161718192021222324&lt;!-- ViewResolver For FreeMarkerConfigurer --&gt; &lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPaths"&gt; &lt;list&gt; &lt;value&gt;/front-end/&lt;/value&gt; &lt;value&gt;/front-end/main-frame&lt;/value&gt; &lt;value&gt;/&lt;/value&gt;&lt;!-- 配置文件路径 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="freemarkerSettings"&gt;&lt;!-- 设置FreeMarker环境属性 --&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;5&lt;/prop&gt;&lt;!--刷新模板的周期，单位为秒 --&gt; &lt;prop key="default_encoding"&gt;UTF-8&lt;/prop&gt;&lt;!--模板的编码格式 --&gt; &lt;prop key="locale"&gt;UTF-8&lt;/prop&gt;&lt;!-- 本地化设置 --&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="time_format"&gt;HH:mm:ss&lt;/prop&gt; &lt;prop key="number_format"&gt;0.####&lt;/prop&gt; &lt;prop key="boolean_format"&gt;true,false&lt;/prop&gt; &lt;prop key="whitespace_stripping"&gt;true&lt;/prop&gt; &lt;prop key="tag_syntax"&gt;auto_detect&lt;/prop&gt; &lt;prop key="url_escaping_charset"&gt;UTF-8&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 前端.ftl文件结构 Controller.java123ModelAndView mav = new ModelAndView();mav.setViewName("/main-frame");return mav; 公用布局模板拆分使用freemarker的macro、import、include指令，我们可以将布局模板拆分为如下几个文件 /layout defaultLayout.ftl footer.ftl header.ftl sidebar.ftldefaultLayout.ftl123456789101112131415161718&lt;#macro layout&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=&quot;width: 700px; text-align:center; font-size:30px;&quot;&gt; &lt;#include &quot;header.ftl&quot;&gt; &lt;#include &quot;sidebar.ftl&quot;&gt; &lt;#-- 在这里嵌入main content --&gt; &lt;#nested&gt; &lt;#include &quot;footer.ftl&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;/#macro&gt; header.ftl1&lt;div style="background-color: #b4efb8;"&gt;header&lt;/div&gt; sidebar.ftl123&lt;div style="width:30%; height:300px; float:left; background-color: #8825ae;"&gt; sidebar&lt;/div&gt; footer.ftl1&lt;div style="background-color: #B3D3F3;"&gt;footer&lt;/div&gt; 那么在任何一个使用该布局的页面，我们只要写如下的代码，修改要嵌入到layout中的main content就好了。1234567891011121314151617181920212223&lt;#-- 引入布局指令的命名空间 --&gt;&lt;#import &quot;../layout/defaultLayout.ftl&quot; as defaultLayout&gt;&lt;#-- 调用布局指令 --&gt;&lt;@defaultLayout.layout&gt; &lt;#-- 将下面这个main content嵌入到layout指令的nested块中 --&gt; &lt;div style=&quot;width:70%; height:300px; float:left; background-color: #12c5ae;&quot;&gt; main content&lt;/div&gt;&lt;/@defaultLayout.layout&gt;&lt;#-- 引入布局指令的命名空间 --&gt;&lt;#import &quot;../layout/defaultLayout.ftl&quot; as defaultLayout&gt; &lt;#-- 调用布局指令 --&gt;&lt;@defaultLayout.layout&gt; &lt;#-- 将下面这个main content嵌入到layout指令的nested块中 --&gt; &lt;div style=&quot;width:70%; height:300px; float:left; background-color: #12c5ae;&quot;&gt; main content&lt;/div&gt; &lt;/@defaultLayout.layout&gt; 而且如果要更换布局，比如修改header，也不用每个页面都去改一遍了。这就实现了模板的可复用。问题使用模板拆分，遇到的问题：123456Caused by: java.io.FileNotFoundException: Template "../main-frame/main-frame.ftl" not found. at freemarker.template.Configuration.getTemplate(Configuration.java:742) at freemarker.core.Environment.getTemplateForInclusion(Environment.java:1694) at freemarker.core.Environment.getTemplateForImporting(Environment.java:1748) at freemarker.core.LibraryLoad.accept(LibraryLoad.java:111) ... 48 more 处理方法：模板路径不对，需要找到模板所在文件夹的上一级再往下找。 freemarker默认配置使用时，如果传到前端的值为null或者不存在，后台会报错。处理方法：12345678910111213&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/template/" /&gt; &lt;property name="freemarkerSettings"&gt; &lt;!-- 设置默认的编码方式，原先是GBK，需要设置成utf-8 --&gt; &lt;props&gt; &lt;!--用于解决前端报空指针问题--&gt; &lt;prop key="classic_compatible"&gt;true&lt;/prop&gt; &lt;prop key="defaultEncoding"&gt;utf-8&lt;/prop&gt; &lt;prop key="template_exception_handler"&gt;rethrow&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 增加了一行：1&lt;prop key="classic_compatible"&gt;true&lt;/prop&gt; 参考链接：点击查看原文问题原因：在freemarker中的空值的处理，默认情况以${xxx}的方式取值会报错，我们一般都采用${xxx?if_exists} 的方式去处理，烦死人了。经过查资料，很多人都建议使用classic_compatible=true的方式来处理，目测单词的意思应该是：“兼容传统模式”的意思。但是经过使用发现这个属性设置为true时，也有很多其他问题，比如boolean值的处理，比如include指令必须使用绝对路径，总之也会带来很多烦人的事情。最后找到源码，在Freemarker源码的Configurable类的isClassicCompatible方法上找到了详细的注释，这里翻译下，不过本人英语比较差，可能会有错误，如果有人不确定可以去看源码。 原注释大意如下： 该方法返回Freemarker模板解析引擎是否工作在“Classic Compatibile”模式下。如果这个模式被激活，则Freemarker模板解析引擎将以以下的方式工作：（类似于1.7.x这个版本的运行方式，这个也是1.7.x的版本被称为“经典的Freemarker”的由来）。（译者注：以下的1、2、3、4、5、6是译者自己加的，方便读者看） 处理未定义的表达式，也就是说”expr”为null值。 1、作为像表达式“”、“${expr}”、“ otherexpr == expr“、“otherexpr != expr”条件表达式或者是“hash[expr]”表达式的参数，这个参数将被当成空字符来对待。（译者注：这里注意空字符和null是不一样的). 2、作为“”、“”这样的表达式的参数，其循环体将不会被执行，和list的长度为0是一样的。 3、作为“”或者其他布尔表达式命令的参数，空值将被当成是false来处理。非布尔数据模型或者逻辑操作数也可以放在“”表达式中，空模型（长度为零的字符串，空的数组或者hash集合）都被当成是false来对待，其他情况下都被当成是true来处理。 4、当布尔值被当成字符串（比如用${…}输出，或者是和其他字符串连接），true值将被转换成“true”字符串处理，false值将被转换成空字符串。 5、提供给和的标量数据模型参数将被当成只包含一个该模型的list来处理。（译者注：就是说，传给和的参数不是list或者数组类型的，而是单个元素，则会被当成只有一个元素的list或者数组） 6、“”标签的路径参数将被作为绝对路径处理。（译者注：这里很多网上的文档都没有提过，是本人经过观察发现的，然后从源码和其注释中找到的。在这种情况下，如果传入的ftl路径是相对路径，则会报找不到文件的异常）。 在其他方面，甚至是在兼容模式下，这个Freemaker解析引擎是2.1引擎，你不会因此而丢掉其他新的功能。 以上就是译文， 那么如果我们设置了全局的classic_compatible属性，而在某个页面上又不想遵守这个属性该怎么办呢？这样就可以在当前这个页面上采用以下的办法，让当前的页面不再支持传统模式：&lt;#setting classic_compatible=false&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习笔记（一）样式篇1]]></title>
    <url>%2F2017%2F05%2F22%2FjQuery-usage%2F</url>
    <content type="text"><![CDATA[前言jQuery是一个JavaScript代码库（或者JavaScript框架）。jQuery的宗旨是“Write Less，Do more”（写更少的代码，做更多的事情）。jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等。 jQuery学习之样式篇选择器 选择器 描述 $(“parent &gt; child”) 子选择器：选择所有指定的“parent”元素中指定的“child”的直接子元素，相邻上下级关系 $(“ancestor descendant”) 后代选择器：选择给定的祖先元素的所有后代元素，包含这个元素的直接子元素或者、孙子、曾孙等 $(“prev + next”) 相邻兄弟选择器：选择紧跟在“prev”元素后的“next”元素 $(“prev ~ siblings”) 一般兄弟选择器：匹配“prev”元素之后的所有兄弟元素。一般兄弟指具有相同的父元素，并匹配过滤“siblings”选择器 $(“:first”) 匹配第一个元素，如$(“input:first”)找到的是第一个input $(“:last”) 匹配最后一个元素 $(“:not(selector)”) 选择所有不是给定选择器的元素 $(“:eq(index)”) 选择索引值为index的元素 $(“:gt(index)”) 选择所有索引值大于index的元素 $(“:lt(index)”) 选择所有索引值小于index的元素 $(“:even”) 索引值为偶数的元素，从零开始 $(“:odd”) 索引值为奇数的元素，从零开始 $(“:header”) 选择所有标题元素，如h1，h2等 $(“:lang(language)”) 选择指定语言的元素 $(“:root”) 选择该文档的根元素 $(“:animated”) 所有正在执行动画效果的元素 $(“:contains(text)”) 所有包含指定文本的元素，如果匹配的文本包含在其子元素中，同样匹配 $(“:has(selector)”) 所有元素中至少包含指定选择器的元素 $(“:parent”) 所有包含子元素或者文本的元素 $(“:empty”) 所有没有子元素的元素 选择器 描述 $(“:visible”) 选择所有显示的元素 $(“:hidden”) 选择所有隐藏的元素 属性选择器 $(“input[name~-‘objname’]”)$(“[attribute|-‘value’]”)选择指定属性值等于给定字符串或以该文字串为前缀（该字符串后跟一个连字符”-“）的元素 选择器 描述 $(“[attribute*=’value’]”) 选择指定属性包含给定的子字符串的元素 $(“[attribute~-‘value’]”) 选择指定属性用空格分割的值中包含一个给定值的元素 $(“[attribute=’value’]”) 选择指定属性是给定值的元素 $(“[attribute!=’value’]”) 选择指定属性不等于给定值的元素 $(“[attribute^=’value’]”) 选择指定属性是以给定字符串开始的元素 $(“[attribute$-‘value’]”) 选择指定属性是以给定字符串结尾的元素 $(“[attribute]”) 选择所有具有指定属性的元素 $(“[attributeFilter1][attributeFilterN]”) 选择匹配所有指定的属性筛选器的元素 表单元素选择器 选择器 描述 $(“:input”) 选择所有input，textarea，select和button元素 $(“:text”) 所有文本框 $(“:password”) 所有密码框 $(“:radio”) 所有单选按钮 $(“:checkbox”) 所有复选框 $(“:submit”) 所有提交按钮 $(“:image”) 所有图像域 $(“:reset”) 所有重置按钮 $(“:button”) 所有按钮 $(“:file”) 所有文件域 表单对象属性筛选选择器 选择器 描述 $(“:enabled”) 匹配可用的表单元素 $(“:disabled”) 匹配不可用的表单元素 $(“:checked”) 匹配被选中的123456789101112131415|$(&quot;:selected&quot;)|匹配被选中的```&lt;option&gt;```元素|### jQuery选择器之特殊选择器thisthis和$(this) 的区别？答：this 是JavaScript中的关键字，指的是当前的上下文对象，简单的说就是方法/属性的拥有者；eg:```jsvar ilucifer = &#123;name:&quot;寒江&quot;,getName:funcion()&#123; //this,就是imooc对象 return this.name; &#125;&#125;ilucifer .getName();//寒江 在JavaScript中this是动态的，即这个上下文对象都是可以被动态改变的(可以通过call,apply等方法)同样的在DOM中this就是指向了这个html元素对象，因为this就是DOM元素本身的一个引用通过把$()方法传入当前的元素对象的引用this，把这个this加工成jQuery对象。 结尾本文整理自慕课网jQuery基础 (一)—样式篇，课程链接：https://www.imooc.com/learn/418；作者：Aaron艾伦https://www.imooc.com/u/290139/courses?sort=publish谢谢]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>前端</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SoapUI 5.3.0调试webservice接口（参数格式XML）]]></title>
    <url>%2F2017%2F03%2F16%2FsoapUI-webservice%2F</url>
    <content type="text"><![CDATA[最近项目中经常要调试webservice接口，从朋友处了解到他们调试webservice接口时使用SoapUI，觉得十分好用，个人也对此十分感兴趣，因此简要记录一下这个工具的使用。 准备 下载SoapUI，我使用的是5.3.0 下载SoapUI传送门 WebService 服务接口进入正题新建调试项目输入项目名称及要调试的接口有效地址，输入完毕点击OKsoapUI会自动获取所有已开放接口，在想要调试的接口方法上面选中右击，选择new request,输入名称后如下图会自动生成如下格式代码；其中 web:in0中填写入参注意：xml格式的入参最好使用 &lt;[CDATA[]]&gt; 包起来。点击左上角的绿色三角就可以调试接口了。新建测试套件 New TestSuite在项目名称上右击，选择 New TestSuite,输入名称保存在自己新建的TestSuite名称上右击，选择 New TestCase,输入名称保存在Test Steps上右击 选择 Add Step –&gt;SOAP Request,输入名称并选择接口，名称最好容易识别一点接下来就可以加入入参进行调试。一次简单的工具使用，记录下来，希望可以帮助到你，祝你好运。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>接口</tag>
        <tag>SoapUI</tag>
        <tag>Webservice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript操作数组array]]></title>
    <url>%2F2016%2F12%2F25%2Fjavascript-array%2F</url>
    <content type="text"><![CDATA[shift：删除原数组第一项，并返回删除元素的值，原数组为空则返回undefined。 unshift:将参数添加到原数组开头，并返回数组的长度。 pop:删除原数组最后一项，并返回删除元素的值，原数组为空则返回undefined。 push:将参数添加到原数组末尾，并返回数组的长度。 shift：删除原数组第一项，并返回删除元素的值，原数组为空则返回undefined。unshift:将参数添加到原数组开头，并返回数组的长度。pop:删除原数组最后一项，并返回删除元素的值，原数组为空则返回undefined。push:将参数添加到原数组末尾，并返回数组的长度。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql导出导入数据库]]></title>
    <url>%2F2016%2F12%2F25%2Fmysql-export-database%2F</url>
    <content type="text"><![CDATA[要在两台不同的电脑上进行开发，数据库需要统一，由于自己第一次完整的设计表结构，因此多次更改表结构，造成了很多不必要的麻烦，需要将数据库导出成sql脚本。 命令行下具体用法如下： mysqldump -用户名 -p密码 -d 数据库名 表名 脚本名;导出数据库名为ssm_web的表结构（其中用户名为root,密码为root,生成的脚本名为db.sql）1mysqldump -u root -proot -d ssm_web&gt;db.sql; 导出数据库名为ssm_web某张表(test)结构1mysqldump -u root -proot -d ssm_web test&gt;test.sql; 导出数据库名为ssm_web所有表结构及表数据（不加-d）1mysqldump -u root -proot ssm_web&gt;e:\lucifer\ssm_web.sql 导出数据库名为ssm_web某张表(test)结构及表数据（不加-d）1mysqldump -u root -proot ssm_web test&gt;test.sql; 导入脚本####1234567MySQL&gt; select now();+---------------------+| now() |+---------------------+| 2013-09-18 13:55:45 |+---------------------+1 row in set (0.00 sec) 执行编写好的sql脚本1234567mysql&gt; source H:/1.sql+---------------------+| now() |+---------------------+| 2013-09-18 13:54:04 |+---------------------+1 row in set (0.00 sec) select …into outfile 方式执行sql12345678910mysql&gt; select now() into outfile 'h:/data/2.sql';Query OK, 1 row affected (0.00 sec)4.使用mysql命令执行H:&gt;mysql -uaHmin -p -e "select now()"Enter passworH: ****+---------------------+| now() |+---------------------+| 2013-09-18 13:57:09 |+---------------------+ mysql命令执行sql，并将查询结果保存到文本中 执行简单sql，如果sql很长，这种方式就不是很适合了。 1mysql -uaHmin -proot test -e "select now()" -N &gt;H:/work/target1.txt 执行复杂sql，可以将复杂的sql事先编辑好，存放到文本中在执行。 1H:&gt; mysql -uroot -pmypwH -h127.0.0.1 -p3306 test &lt; H:/work/source.sql &gt; H:/work/target.txt 将最后一种执行方式加上操作系统的定时任务，就可以在mysql中实现定时执行sql，并保存执行结果的目的了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防止js全局变量污染方法总结]]></title>
    <url>%2F2016%2F11%2F25%2F%E9%98%B2%E6%AD%A2js%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%B1%A1%E6%9F%93%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[转载自防止js全局变量污染方法总结-待续javaScript 可以随意定义保存所有应用资源的全局变量。但全局变量可以削弱程序灵活性，增大了模块之间的耦合性。在多人协作时，如果定义过多的全局变量 有可能造成全局变量冲突，也就是全局变量污染问题,以下是两种解决办法 定义全局变量命名空间只创建一个全局变量，并定义该变量为当前应用容器，把其他全局变量追加在该命名空间下123456789var MY=&#123;&#125;; my.name=&#123; big_name:"zhangsan", small_name:"lisi"&#125;;my.work=&#123; school_work:"study", family_work:"we are"&#125;; 利用匿名函数将脚本包裹起来12345678(function()&#123; var exp=&#123;&#125;; var name="aa"; exp.method=function()&#123; return name;&#125;; window.ex=exp;&#125;)();]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SqlServer2008R2-问题汇总]]></title>
    <url>%2F2016%2F09%2F07%2Fsqlserver2008r2%2F</url>
    <content type="text"><![CDATA[新安装数据库sqlserver2008r2,使用客户端登录不上问题处理 1. 新安装数据库sqlserver2008r2,使用客户端登录不上问题处理问题处理：鼠标右键【计算机】–&gt;【管理】，打开界面如下：选择自己数据库的实例名：选择TCP/IP：右键【属性】，将所有TCP动态端口的【0】删掉，TCP端口设为1433；重启服务，即可连接。]]></content>
      <categories>
        <category>错误</category>
      </categories>
      <tags>
        <tag>SqlServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript常用功能]]></title>
    <url>%2F2016%2F09%2F03%2Fjavascript-utils%2F</url>
    <content type="text"><![CDATA[使用JS获取request参数 document.write(‘&lt;%=request.getAttribute(“param”)%&gt;’); window.navigator.userAgent 记录浏览器信息以及操作系统信息。 var searchParam = location.search.配合使用string的相关方法即可得到。 js获取上下文路径：123456getContextPath: function () &#123; var pathName = document.location.pathname; var index = pathName.substr(1).indexOf("/"); var result = pathName.substr(0, index + 1); return result; &#125; js获取项目路径：123456789101112function getRootPath()&#123; //获取当前网址，如： http://localhost:8083/uimcardprj/share/meun.jsp var curWwwPath=window.document.location.href; //获取主机地址之后的目录，如： uimcardprj/share/meun.jsp var pathName=window.document.location.pathname; var pos=curWwwPath.indexOf(pathName); //获取主机地址，如： http://localhost:8083 var localhostPaht=curWwwPath.substring(0,pos); //获取带"/"的项目名，如：/uimcardprj var projectName=pathName.substring(0,pathName.substr(1).indexOf('/')+1); return(localhostPaht+projectName); &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用apache的poi组件上传并解析excel]]></title>
    <url>%2F2016%2F07%2F27%2Fexcel-upload-parse%2F</url>
    <content type="text"><![CDATA[通过apache的poi组件解析excel，以便将数据存储到数据库中。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public List&lt;String[]&gt; paseUserStoryFile(MultipartFile file) &#123; List&lt;String[]&gt; list = new ArrayList&lt;String[]&gt;(); try &#123; POIFSFileSystem pois = new POIFSFileSystem(file.getInputStream()); //新建WorkBook HSSFWorkbook wb = new HSSFWorkbook(pois); //获取Sheet（工作薄）总个数 int sheetNumber = wb.getNumberOfSheets(); for (int i = 0; i &lt; sheetNumber; i++) &#123; //获取Sheet（工作薄） HSSFSheet sheet = wb.getSheetAt(i); //开始行数 int firstRow = sheet.getFirstRowNum(); //结束行数 int lastRow = sheet.getLastRowNum(); //判断该Sheet（工作薄)是否为空 boolean isEmpty = false; if (firstRow == lastRow) &#123; isEmpty = true; &#125; if (!isEmpty) &#123; for (int j = firstRow + 1; j &lt;= lastRow; j++) &#123; //获取一行 HSSFRow row = sheet.getRow(j); //开始列数 int firstCell = row.getFirstCellNum(); //结束列数 int lastCell = row.getLastCellNum(); //判断该行是否为空 String[] value = new String[lastCell]; if (firstCell != lastCell) &#123; for (int k = firstCell; k &lt; lastCell; k++) &#123; //获取一个单元格 HSSFCell cell = row.getCell(k); Object str = null; //获取单元格，值的类型 int cellType = cell.getCellType(); if (cellType == 0) &#123; str = cell.getNumericCellValue(); &#125; else if (cellType == 1) &#123; str = cell.getStringCellValue(); &#125; else if (cellType == 2) &#123; &#125; else if (cellType == 4) &#123; str = cell.getBooleanCellValue(); &#125; value[k] = (String) str; &#125; &#125; //每一行循环完对应的就是一个用户故事的所有属性全部拿到 list.add(value); &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return list; &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>java</tag>
        <tag>excel</tag>
        <tag>poi</tag>
      </tags>
  </entry>
</search>
